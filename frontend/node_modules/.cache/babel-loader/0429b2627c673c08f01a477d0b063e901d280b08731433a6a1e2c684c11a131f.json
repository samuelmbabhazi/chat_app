{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StrictEventEmitter = void 0;\nconst events_1 = require(\"events\");\n/**\n * Strictly typed version of an `EventEmitter`. A `TypedEventEmitter` takes type\n * parameters for mappings of event names to event data types, and strictly\n * types method calls to the `EventEmitter` according to these event maps.\n *\n * @typeParam ListenEvents - `EventsMap` of user-defined events that can be\n * listened to with `on` or `once`\n * @typeParam EmitEvents - `EventsMap` of user-defined events that can be\n * emitted with `emit`\n * @typeParam ReservedEvents - `EventsMap` of reserved events, that can be\n * emitted by socket.io with `emitReserved`, and can be listened to with\n * `listen`.\n */\nclass StrictEventEmitter extends events_1.EventEmitter {\n  /**\n   * Adds the `listener` function as an event listener for `ev`.\n   *\n   * @param ev Name of the event\n   * @param listener Callback function\n   */\n  on(ev, listener) {\n    return super.on(ev, listener);\n  }\n  /**\n   * Adds a one-time `listener` function as an event listener for `ev`.\n   *\n   * @param ev Name of the event\n   * @param listener Callback function\n   */\n  once(ev, listener) {\n    return super.once(ev, listener);\n  }\n  /**\n   * Emits an event.\n   *\n   * @param ev Name of the event\n   * @param args Values to send to listeners of this event\n   */\n  emit(ev) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    return super.emit(ev, ...args);\n  }\n  /**\n   * Emits a reserved event.\n   *\n   * This method is `protected`, so that only a class extending\n   * `StrictEventEmitter` can emit its own reserved events.\n   *\n   * @param ev Reserved event name\n   * @param args Arguments to emit along with the event\n   */\n  emitReserved(ev) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    return super.emit(ev, ...args);\n  }\n  /**\n   * Emits an event.\n   *\n   * This method is `protected`, so that only a class extending\n   * `StrictEventEmitter` can get around the strict typing. This is useful for\n   * calling `emit.apply`, which can be called as `emitUntyped.apply`.\n   *\n   * @param ev Event name\n   * @param args Arguments to emit along with the event\n   */\n  emitUntyped(ev) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    return super.emit(ev, ...args);\n  }\n  /**\n   * Returns the listeners listening to an event.\n   *\n   * @param event Event name\n   * @returns Array of listeners subscribed to `event`\n   */\n  listeners(event) {\n    return super.listeners(event);\n  }\n}\nexports.StrictEventEmitter = StrictEventEmitter;","map":{"version":3,"names":["Object","defineProperty","exports","value","StrictEventEmitter","events_1","require","EventEmitter","on","ev","listener","once","emit","args","emitReserved","emitUntyped","listeners","event"],"sources":["/home/samuel/Documents/chatApp/node_modules/socket.io/dist/typed-events.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StrictEventEmitter = void 0;\nconst events_1 = require(\"events\");\n/**\n * Strictly typed version of an `EventEmitter`. A `TypedEventEmitter` takes type\n * parameters for mappings of event names to event data types, and strictly\n * types method calls to the `EventEmitter` according to these event maps.\n *\n * @typeParam ListenEvents - `EventsMap` of user-defined events that can be\n * listened to with `on` or `once`\n * @typeParam EmitEvents - `EventsMap` of user-defined events that can be\n * emitted with `emit`\n * @typeParam ReservedEvents - `EventsMap` of reserved events, that can be\n * emitted by socket.io with `emitReserved`, and can be listened to with\n * `listen`.\n */\nclass StrictEventEmitter extends events_1.EventEmitter {\n    /**\n     * Adds the `listener` function as an event listener for `ev`.\n     *\n     * @param ev Name of the event\n     * @param listener Callback function\n     */\n    on(ev, listener) {\n        return super.on(ev, listener);\n    }\n    /**\n     * Adds a one-time `listener` function as an event listener for `ev`.\n     *\n     * @param ev Name of the event\n     * @param listener Callback function\n     */\n    once(ev, listener) {\n        return super.once(ev, listener);\n    }\n    /**\n     * Emits an event.\n     *\n     * @param ev Name of the event\n     * @param args Values to send to listeners of this event\n     */\n    emit(ev, ...args) {\n        return super.emit(ev, ...args);\n    }\n    /**\n     * Emits a reserved event.\n     *\n     * This method is `protected`, so that only a class extending\n     * `StrictEventEmitter` can emit its own reserved events.\n     *\n     * @param ev Reserved event name\n     * @param args Arguments to emit along with the event\n     */\n    emitReserved(ev, ...args) {\n        return super.emit(ev, ...args);\n    }\n    /**\n     * Emits an event.\n     *\n     * This method is `protected`, so that only a class extending\n     * `StrictEventEmitter` can get around the strict typing. This is useful for\n     * calling `emit.apply`, which can be called as `emitUntyped.apply`.\n     *\n     * @param ev Event name\n     * @param args Arguments to emit along with the event\n     */\n    emitUntyped(ev, ...args) {\n        return super.emit(ev, ...args);\n    }\n    /**\n     * Returns the listeners listening to an event.\n     *\n     * @param event Event name\n     * @returns Array of listeners subscribed to `event`\n     */\n    listeners(event) {\n        return super.listeners(event);\n    }\n}\nexports.StrictEventEmitter = StrictEventEmitter;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,kBAAkB,GAAG,KAAK,CAAC;AACnC,MAAMC,QAAQ,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMF,kBAAkB,SAASC,QAAQ,CAACE,YAAY,CAAC;EACnD;AACJ;AACA;AACA;AACA;AACA;EACIC,EAAE,CAACC,EAAE,EAAEC,QAAQ,EAAE;IACb,OAAO,KAAK,CAACF,EAAE,CAACC,EAAE,EAAEC,QAAQ,CAAC;EACjC;EACA;AACJ;AACA;AACA;AACA;AACA;EACIC,IAAI,CAACF,EAAE,EAAEC,QAAQ,EAAE;IACf,OAAO,KAAK,CAACC,IAAI,CAACF,EAAE,EAAEC,QAAQ,CAAC;EACnC;EACA;AACJ;AACA;AACA;AACA;AACA;EACIE,IAAI,CAACH,EAAE,EAAW;IAAA,kCAANI,IAAI;MAAJA,IAAI;IAAA;IACZ,OAAO,KAAK,CAACD,IAAI,CAACH,EAAE,EAAE,GAAGI,IAAI,CAAC;EAClC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,YAAY,CAACL,EAAE,EAAW;IAAA,mCAANI,IAAI;MAAJA,IAAI;IAAA;IACpB,OAAO,KAAK,CAACD,IAAI,CAACH,EAAE,EAAE,GAAGI,IAAI,CAAC;EAClC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,WAAW,CAACN,EAAE,EAAW;IAAA,mCAANI,IAAI;MAAJA,IAAI;IAAA;IACnB,OAAO,KAAK,CAACD,IAAI,CAACH,EAAE,EAAE,GAAGI,IAAI,CAAC;EAClC;EACA;AACJ;AACA;AACA;AACA;AACA;EACIG,SAAS,CAACC,KAAK,EAAE;IACb,OAAO,KAAK,CAACD,SAAS,CAACC,KAAK,CAAC;EACjC;AACJ;AACAf,OAAO,CAACE,kBAAkB,GAAGA,kBAAkB"},"metadata":{},"sourceType":"script","externalDependencies":[]}