{"ast":null,"code":"'use strict';\n\nconst {\n  kForOnEventAttribute,\n  kListener\n} = require('./constants');\nconst kCode = Symbol('kCode');\nconst kData = Symbol('kData');\nconst kError = Symbol('kError');\nconst kMessage = Symbol('kMessage');\nconst kReason = Symbol('kReason');\nconst kTarget = Symbol('kTarget');\nconst kType = Symbol('kType');\nconst kWasClean = Symbol('kWasClean');\n\n/**\n * Class representing an event.\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n\n  /**\n   * @type {*}\n   */\n  get target() {\n    return this[kTarget];\n  }\n\n  /**\n   * @type {String}\n   */\n  get type() {\n    return this[kType];\n  }\n}\nObject.defineProperty(Event.prototype, 'target', {\n  enumerable: true\n});\nObject.defineProperty(Event.prototype, 'type', {\n  enumerable: true\n});\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(type);\n    this[kCode] = options.code === undefined ? 0 : options.code;\n    this[kReason] = options.reason === undefined ? '' : options.reason;\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get code() {\n    return this[kCode];\n  }\n\n  /**\n   * @type {String}\n   */\n  get reason() {\n    return this[kReason];\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get wasClean() {\n    return this[kWasClean];\n  }\n}\nObject.defineProperty(CloseEvent.prototype, 'code', {\n  enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, 'reason', {\n  enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, 'wasClean', {\n  enumerable: true\n});\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(type);\n    this[kError] = options.error === undefined ? null : options.error;\n    this[kMessage] = options.message === undefined ? '' : options.message;\n  }\n\n  /**\n   * @type {*}\n   */\n  get error() {\n    return this[kError];\n  }\n\n  /**\n   * @type {String}\n   */\n  get message() {\n    return this[kMessage];\n  }\n}\nObject.defineProperty(ErrorEvent.prototype, 'error', {\n  enumerable: true\n});\nObject.defineProperty(ErrorEvent.prototype, 'message', {\n  enumerable: true\n});\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(type);\n    this[kData] = options.data === undefined ? null : options.data;\n  }\n\n  /**\n   * @type {*}\n   */\n  get data() {\n    return this[kData];\n  }\n}\nObject.defineProperty(MessageEvent.prototype, 'data', {\n  enumerable: true\n});\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {Function} listener The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, listener) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let wrapper;\n    if (type === 'message') {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent('message', {\n          data: isBinary ? data : data.toString()\n        });\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'close') {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent('close', {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'error') {\n      wrapper = function onError(error) {\n        const event = new ErrorEvent('error', {\n          error,\n          message: error.message\n        });\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'open') {\n      wrapper = function onOpen() {\n        const event = new Event('open');\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else {\n      return;\n    }\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n    wrapper[kListener] = listener;\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {Function} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n};\nmodule.exports = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};","map":{"version":3,"names":["kForOnEventAttribute","kListener","require","kCode","Symbol","kData","kError","kMessage","kReason","kTarget","kType","kWasClean","Event","constructor","type","target","Object","defineProperty","prototype","enumerable","CloseEvent","options","code","undefined","reason","wasClean","ErrorEvent","error","message","MessageEvent","data","EventTarget","addEventListener","listener","wrapper","onMessage","isBinary","event","toString","call","onClose","_closeFrameReceived","_closeFrameSent","onError","onOpen","once","on","removeEventListener","handler","listeners","removeListener","module","exports"],"sources":["/home/samuel/Documents/chatApp/node_modules/ws/lib/event-target.js"],"sourcesContent":["'use strict';\n\nconst { kForOnEventAttribute, kListener } = require('./constants');\n\nconst kCode = Symbol('kCode');\nconst kData = Symbol('kData');\nconst kError = Symbol('kError');\nconst kMessage = Symbol('kMessage');\nconst kReason = Symbol('kReason');\nconst kTarget = Symbol('kTarget');\nconst kType = Symbol('kType');\nconst kWasClean = Symbol('kWasClean');\n\n/**\n * Class representing an event.\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n\n  /**\n   * @type {*}\n   */\n  get target() {\n    return this[kTarget];\n  }\n\n  /**\n   * @type {String}\n   */\n  get type() {\n    return this[kType];\n  }\n}\n\nObject.defineProperty(Event.prototype, 'target', { enumerable: true });\nObject.defineProperty(Event.prototype, 'type', { enumerable: true });\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kCode] = options.code === undefined ? 0 : options.code;\n    this[kReason] = options.reason === undefined ? '' : options.reason;\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get code() {\n    return this[kCode];\n  }\n\n  /**\n   * @type {String}\n   */\n  get reason() {\n    return this[kReason];\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get wasClean() {\n    return this[kWasClean];\n  }\n}\n\nObject.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kError] = options.error === undefined ? null : options.error;\n    this[kMessage] = options.message === undefined ? '' : options.message;\n  }\n\n  /**\n   * @type {*}\n   */\n  get error() {\n    return this[kError];\n  }\n\n  /**\n   * @type {String}\n   */\n  get message() {\n    return this[kMessage];\n  }\n}\n\nObject.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });\nObject.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kData] = options.data === undefined ? null : options.data;\n  }\n\n  /**\n   * @type {*}\n   */\n  get data() {\n    return this[kData];\n  }\n}\n\nObject.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {Function} listener The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, listener, options = {}) {\n    let wrapper;\n\n    if (type === 'message') {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent('message', {\n          data: isBinary ? data : data.toString()\n        });\n\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'close') {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent('close', {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'error') {\n      wrapper = function onError(error) {\n        const event = new ErrorEvent('error', {\n          error,\n          message: error.message\n        });\n\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else if (type === 'open') {\n      wrapper = function onOpen() {\n        const event = new Event('open');\n\n        event[kTarget] = this;\n        listener.call(this, event);\n      };\n    } else {\n      return;\n    }\n\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n    wrapper[kListener] = listener;\n\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {Function} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n};\n\nmodule.exports = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}