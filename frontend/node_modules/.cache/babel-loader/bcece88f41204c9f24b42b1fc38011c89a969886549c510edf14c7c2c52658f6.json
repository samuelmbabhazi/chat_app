{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Adapter = void 0;\nconst events_1 = require(\"events\");\nclass Adapter extends events_1.EventEmitter {\n  /**\n   * In-memory adapter constructor.\n   *\n   * @param {Namespace} nsp\n   */\n  constructor(nsp) {\n    super();\n    this.nsp = nsp;\n    this.rooms = new Map();\n    this.sids = new Map();\n    this.encoder = nsp.server.encoder;\n  }\n  /**\n   * To be overridden\n   */\n  init() {}\n  /**\n   * To be overridden\n   */\n  close() {}\n  /**\n   * Returns the number of Socket.IO servers in the cluster\n   *\n   * @public\n   */\n  serverCount() {\n    return Promise.resolve(1);\n  }\n  /**\n   * Adds a socket to a list of room.\n   *\n   * @param {SocketId}  id      the socket id\n   * @param {Set<Room>} rooms   a set of rooms\n   * @public\n   */\n  addAll(id, rooms) {\n    if (!this.sids.has(id)) {\n      this.sids.set(id, new Set());\n    }\n    for (const room of rooms) {\n      this.sids.get(id).add(room);\n      if (!this.rooms.has(room)) {\n        this.rooms.set(room, new Set());\n        this.emit(\"create-room\", room);\n      }\n      if (!this.rooms.get(room).has(id)) {\n        this.rooms.get(room).add(id);\n        this.emit(\"join-room\", room, id);\n      }\n    }\n  }\n  /**\n   * Removes a socket from a room.\n   *\n   * @param {SocketId} id     the socket id\n   * @param {Room}     room   the room name\n   */\n  del(id, room) {\n    if (this.sids.has(id)) {\n      this.sids.get(id).delete(room);\n    }\n    this._del(room, id);\n  }\n  _del(room, id) {\n    const _room = this.rooms.get(room);\n    if (_room != null) {\n      const deleted = _room.delete(id);\n      if (deleted) {\n        this.emit(\"leave-room\", room, id);\n      }\n      if (_room.size === 0 && this.rooms.delete(room)) {\n        this.emit(\"delete-room\", room);\n      }\n    }\n  }\n  /**\n   * Removes a socket from all rooms it's joined.\n   *\n   * @param {SocketId} id   the socket id\n   */\n  delAll(id) {\n    if (!this.sids.has(id)) {\n      return;\n    }\n    for (const room of this.sids.get(id)) {\n      this._del(room, id);\n    }\n    this.sids.delete(id);\n  }\n  /**\n   * Broadcasts a packet.\n   *\n   * Options:\n   *  - `flags` {Object} flags for this packet\n   *  - `except` {Array} sids that should be excluded\n   *  - `rooms` {Array} list of rooms to broadcast to\n   *\n   * @param {Object} packet   the packet object\n   * @param {Object} opts     the options\n   * @public\n   */\n  broadcast(packet, opts) {\n    const flags = opts.flags || {};\n    const packetOpts = {\n      preEncoded: true,\n      volatile: flags.volatile,\n      compress: flags.compress\n    };\n    packet.nsp = this.nsp.name;\n    const encodedPackets = this.encoder.encode(packet);\n    this.apply(opts, socket => {\n      if (typeof socket.notifyOutgoingListeners === \"function\") {\n        socket.notifyOutgoingListeners(packet);\n      }\n      socket.client.writeToEngine(encodedPackets, packetOpts);\n    });\n  }\n  /**\n   * Broadcasts a packet and expects multiple acknowledgements.\n   *\n   * Options:\n   *  - `flags` {Object} flags for this packet\n   *  - `except` {Array} sids that should be excluded\n   *  - `rooms` {Array} list of rooms to broadcast to\n   *\n   * @param {Object} packet   the packet object\n   * @param {Object} opts     the options\n   * @param clientCountCallback - the number of clients that received the packet\n   * @param ack                 - the callback that will be called for each client response\n   *\n   * @public\n   */\n  broadcastWithAck(packet, opts, clientCountCallback, ack) {\n    const flags = opts.flags || {};\n    const packetOpts = {\n      preEncoded: true,\n      volatile: flags.volatile,\n      compress: flags.compress\n    };\n    packet.nsp = this.nsp.name;\n    // we can use the same id for each packet, since the _ids counter is common (no duplicate)\n    packet.id = this.nsp._ids++;\n    const encodedPackets = this.encoder.encode(packet);\n    let clientCount = 0;\n    this.apply(opts, socket => {\n      // track the total number of acknowledgements that are expected\n      clientCount++;\n      // call the ack callback for each client response\n      socket.acks.set(packet.id, ack);\n      if (typeof socket.notifyOutgoingListeners === \"function\") {\n        socket.notifyOutgoingListeners(packet);\n      }\n      socket.client.writeToEngine(encodedPackets, packetOpts);\n    });\n    clientCountCallback(clientCount);\n  }\n  /**\n   * Gets a list of sockets by sid.\n   *\n   * @param {Set<Room>} rooms   the explicit set of rooms to check.\n   */\n  sockets(rooms) {\n    const sids = new Set();\n    this.apply({\n      rooms\n    }, socket => {\n      sids.add(socket.id);\n    });\n    return Promise.resolve(sids);\n  }\n  /**\n   * Gets the list of rooms a given socket has joined.\n   *\n   * @param {SocketId} id   the socket id\n   */\n  socketRooms(id) {\n    return this.sids.get(id);\n  }\n  /**\n   * Returns the matching socket instances\n   *\n   * @param opts - the filters to apply\n   */\n  fetchSockets(opts) {\n    const sockets = [];\n    this.apply(opts, socket => {\n      sockets.push(socket);\n    });\n    return Promise.resolve(sockets);\n  }\n  /**\n   * Makes the matching socket instances join the specified rooms\n   *\n   * @param opts - the filters to apply\n   * @param rooms - the rooms to join\n   */\n  addSockets(opts, rooms) {\n    this.apply(opts, socket => {\n      socket.join(rooms);\n    });\n  }\n  /**\n   * Makes the matching socket instances leave the specified rooms\n   *\n   * @param opts - the filters to apply\n   * @param rooms - the rooms to leave\n   */\n  delSockets(opts, rooms) {\n    this.apply(opts, socket => {\n      rooms.forEach(room => socket.leave(room));\n    });\n  }\n  /**\n   * Makes the matching socket instances disconnect\n   *\n   * @param opts - the filters to apply\n   * @param close - whether to close the underlying connection\n   */\n  disconnectSockets(opts, close) {\n    this.apply(opts, socket => {\n      socket.disconnect(close);\n    });\n  }\n  apply(opts, callback) {\n    const rooms = opts.rooms;\n    const except = this.computeExceptSids(opts.except);\n    if (rooms.size) {\n      const ids = new Set();\n      for (const room of rooms) {\n        if (!this.rooms.has(room)) continue;\n        for (const id of this.rooms.get(room)) {\n          if (ids.has(id) || except.has(id)) continue;\n          const socket = this.nsp.sockets.get(id);\n          if (socket) {\n            callback(socket);\n            ids.add(id);\n          }\n        }\n      }\n    } else {\n      for (const [id] of this.sids) {\n        if (except.has(id)) continue;\n        const socket = this.nsp.sockets.get(id);\n        if (socket) callback(socket);\n      }\n    }\n  }\n  computeExceptSids(exceptRooms) {\n    const exceptSids = new Set();\n    if (exceptRooms && exceptRooms.size > 0) {\n      for (const room of exceptRooms) {\n        if (this.rooms.has(room)) {\n          this.rooms.get(room).forEach(sid => exceptSids.add(sid));\n        }\n      }\n    }\n    return exceptSids;\n  }\n  /**\n   * Send a packet to the other Socket.IO servers in the cluster\n   * @param packet - an array of arguments, which may include an acknowledgement callback at the end\n   */\n  serverSideEmit(packet) {\n    console.warn(\"this adapter does not support the serverSideEmit() functionality\");\n  }\n}\nexports.Adapter = Adapter;","map":{"version":3,"names":["Object","defineProperty","exports","value","Adapter","events_1","require","EventEmitter","constructor","nsp","rooms","Map","sids","encoder","server","init","close","serverCount","Promise","resolve","addAll","id","has","set","Set","room","get","add","emit","del","delete","_del","_room","deleted","size","delAll","broadcast","packet","opts","flags","packetOpts","preEncoded","volatile","compress","name","encodedPackets","encode","apply","socket","notifyOutgoingListeners","client","writeToEngine","broadcastWithAck","clientCountCallback","ack","_ids","clientCount","acks","sockets","socketRooms","fetchSockets","push","addSockets","join","delSockets","forEach","leave","disconnectSockets","disconnect","callback","except","computeExceptSids","ids","exceptRooms","exceptSids","sid","serverSideEmit","console","warn"],"sources":["/home/samuel/Documents/chatApp/node_modules/socket.io-adapter/dist/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Adapter = void 0;\nconst events_1 = require(\"events\");\nclass Adapter extends events_1.EventEmitter {\n    /**\n     * In-memory adapter constructor.\n     *\n     * @param {Namespace} nsp\n     */\n    constructor(nsp) {\n        super();\n        this.nsp = nsp;\n        this.rooms = new Map();\n        this.sids = new Map();\n        this.encoder = nsp.server.encoder;\n    }\n    /**\n     * To be overridden\n     */\n    init() { }\n    /**\n     * To be overridden\n     */\n    close() { }\n    /**\n     * Returns the number of Socket.IO servers in the cluster\n     *\n     * @public\n     */\n    serverCount() {\n        return Promise.resolve(1);\n    }\n    /**\n     * Adds a socket to a list of room.\n     *\n     * @param {SocketId}  id      the socket id\n     * @param {Set<Room>} rooms   a set of rooms\n     * @public\n     */\n    addAll(id, rooms) {\n        if (!this.sids.has(id)) {\n            this.sids.set(id, new Set());\n        }\n        for (const room of rooms) {\n            this.sids.get(id).add(room);\n            if (!this.rooms.has(room)) {\n                this.rooms.set(room, new Set());\n                this.emit(\"create-room\", room);\n            }\n            if (!this.rooms.get(room).has(id)) {\n                this.rooms.get(room).add(id);\n                this.emit(\"join-room\", room, id);\n            }\n        }\n    }\n    /**\n     * Removes a socket from a room.\n     *\n     * @param {SocketId} id     the socket id\n     * @param {Room}     room   the room name\n     */\n    del(id, room) {\n        if (this.sids.has(id)) {\n            this.sids.get(id).delete(room);\n        }\n        this._del(room, id);\n    }\n    _del(room, id) {\n        const _room = this.rooms.get(room);\n        if (_room != null) {\n            const deleted = _room.delete(id);\n            if (deleted) {\n                this.emit(\"leave-room\", room, id);\n            }\n            if (_room.size === 0 && this.rooms.delete(room)) {\n                this.emit(\"delete-room\", room);\n            }\n        }\n    }\n    /**\n     * Removes a socket from all rooms it's joined.\n     *\n     * @param {SocketId} id   the socket id\n     */\n    delAll(id) {\n        if (!this.sids.has(id)) {\n            return;\n        }\n        for (const room of this.sids.get(id)) {\n            this._del(room, id);\n        }\n        this.sids.delete(id);\n    }\n    /**\n     * Broadcasts a packet.\n     *\n     * Options:\n     *  - `flags` {Object} flags for this packet\n     *  - `except` {Array} sids that should be excluded\n     *  - `rooms` {Array} list of rooms to broadcast to\n     *\n     * @param {Object} packet   the packet object\n     * @param {Object} opts     the options\n     * @public\n     */\n    broadcast(packet, opts) {\n        const flags = opts.flags || {};\n        const packetOpts = {\n            preEncoded: true,\n            volatile: flags.volatile,\n            compress: flags.compress\n        };\n        packet.nsp = this.nsp.name;\n        const encodedPackets = this.encoder.encode(packet);\n        this.apply(opts, socket => {\n            if (typeof socket.notifyOutgoingListeners === \"function\") {\n                socket.notifyOutgoingListeners(packet);\n            }\n            socket.client.writeToEngine(encodedPackets, packetOpts);\n        });\n    }\n    /**\n     * Broadcasts a packet and expects multiple acknowledgements.\n     *\n     * Options:\n     *  - `flags` {Object} flags for this packet\n     *  - `except` {Array} sids that should be excluded\n     *  - `rooms` {Array} list of rooms to broadcast to\n     *\n     * @param {Object} packet   the packet object\n     * @param {Object} opts     the options\n     * @param clientCountCallback - the number of clients that received the packet\n     * @param ack                 - the callback that will be called for each client response\n     *\n     * @public\n     */\n    broadcastWithAck(packet, opts, clientCountCallback, ack) {\n        const flags = opts.flags || {};\n        const packetOpts = {\n            preEncoded: true,\n            volatile: flags.volatile,\n            compress: flags.compress\n        };\n        packet.nsp = this.nsp.name;\n        // we can use the same id for each packet, since the _ids counter is common (no duplicate)\n        packet.id = this.nsp._ids++;\n        const encodedPackets = this.encoder.encode(packet);\n        let clientCount = 0;\n        this.apply(opts, socket => {\n            // track the total number of acknowledgements that are expected\n            clientCount++;\n            // call the ack callback for each client response\n            socket.acks.set(packet.id, ack);\n            if (typeof socket.notifyOutgoingListeners === \"function\") {\n                socket.notifyOutgoingListeners(packet);\n            }\n            socket.client.writeToEngine(encodedPackets, packetOpts);\n        });\n        clientCountCallback(clientCount);\n    }\n    /**\n     * Gets a list of sockets by sid.\n     *\n     * @param {Set<Room>} rooms   the explicit set of rooms to check.\n     */\n    sockets(rooms) {\n        const sids = new Set();\n        this.apply({ rooms }, socket => {\n            sids.add(socket.id);\n        });\n        return Promise.resolve(sids);\n    }\n    /**\n     * Gets the list of rooms a given socket has joined.\n     *\n     * @param {SocketId} id   the socket id\n     */\n    socketRooms(id) {\n        return this.sids.get(id);\n    }\n    /**\n     * Returns the matching socket instances\n     *\n     * @param opts - the filters to apply\n     */\n    fetchSockets(opts) {\n        const sockets = [];\n        this.apply(opts, socket => {\n            sockets.push(socket);\n        });\n        return Promise.resolve(sockets);\n    }\n    /**\n     * Makes the matching socket instances join the specified rooms\n     *\n     * @param opts - the filters to apply\n     * @param rooms - the rooms to join\n     */\n    addSockets(opts, rooms) {\n        this.apply(opts, socket => {\n            socket.join(rooms);\n        });\n    }\n    /**\n     * Makes the matching socket instances leave the specified rooms\n     *\n     * @param opts - the filters to apply\n     * @param rooms - the rooms to leave\n     */\n    delSockets(opts, rooms) {\n        this.apply(opts, socket => {\n            rooms.forEach(room => socket.leave(room));\n        });\n    }\n    /**\n     * Makes the matching socket instances disconnect\n     *\n     * @param opts - the filters to apply\n     * @param close - whether to close the underlying connection\n     */\n    disconnectSockets(opts, close) {\n        this.apply(opts, socket => {\n            socket.disconnect(close);\n        });\n    }\n    apply(opts, callback) {\n        const rooms = opts.rooms;\n        const except = this.computeExceptSids(opts.except);\n        if (rooms.size) {\n            const ids = new Set();\n            for (const room of rooms) {\n                if (!this.rooms.has(room))\n                    continue;\n                for (const id of this.rooms.get(room)) {\n                    if (ids.has(id) || except.has(id))\n                        continue;\n                    const socket = this.nsp.sockets.get(id);\n                    if (socket) {\n                        callback(socket);\n                        ids.add(id);\n                    }\n                }\n            }\n        }\n        else {\n            for (const [id] of this.sids) {\n                if (except.has(id))\n                    continue;\n                const socket = this.nsp.sockets.get(id);\n                if (socket)\n                    callback(socket);\n            }\n        }\n    }\n    computeExceptSids(exceptRooms) {\n        const exceptSids = new Set();\n        if (exceptRooms && exceptRooms.size > 0) {\n            for (const room of exceptRooms) {\n                if (this.rooms.has(room)) {\n                    this.rooms.get(room).forEach(sid => exceptSids.add(sid));\n                }\n            }\n        }\n        return exceptSids;\n    }\n    /**\n     * Send a packet to the other Socket.IO servers in the cluster\n     * @param packet - an array of arguments, which may include an acknowledgement callback at the end\n     */\n    serverSideEmit(packet) {\n        console.warn(\"this adapter does not support the serverSideEmit() functionality\");\n    }\n}\nexports.Adapter = Adapter;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}