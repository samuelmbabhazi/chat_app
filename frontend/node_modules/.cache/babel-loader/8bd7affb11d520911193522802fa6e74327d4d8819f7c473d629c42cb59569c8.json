{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Client = void 0;\nconst socket_io_parser_1 = require(\"socket.io-parser\");\nconst debugModule = require(\"debug\");\nconst url = require(\"url\");\nconst debug = debugModule(\"socket.io:client\");\nclass Client {\n  /**\n   * Client constructor.\n   *\n   * @param server instance\n   * @param conn\n   * @package\n   */\n  constructor(server, conn) {\n    this.sockets = new Map();\n    this.nsps = new Map();\n    this.server = server;\n    this.conn = conn;\n    this.encoder = server.encoder;\n    this.decoder = new server._parser.Decoder();\n    this.id = conn.id;\n    this.setup();\n  }\n  /**\n   * @return the reference to the request that originated the Engine.IO connection\n   *\n   * @public\n   */\n  get request() {\n    return this.conn.request;\n  }\n  /**\n   * Sets up event listeners.\n   *\n   * @private\n   */\n  setup() {\n    this.onclose = this.onclose.bind(this);\n    this.ondata = this.ondata.bind(this);\n    this.onerror = this.onerror.bind(this);\n    this.ondecoded = this.ondecoded.bind(this);\n    // @ts-ignore\n    this.decoder.on(\"decoded\", this.ondecoded);\n    this.conn.on(\"data\", this.ondata);\n    this.conn.on(\"error\", this.onerror);\n    this.conn.on(\"close\", this.onclose);\n    this.connectTimeout = setTimeout(() => {\n      if (this.nsps.size === 0) {\n        debug(\"no namespace joined yet, close the client\");\n        this.close();\n      } else {\n        debug(\"the client has already joined a namespace, nothing to do\");\n      }\n    }, this.server._connectTimeout);\n  }\n  /**\n   * Connects a client to a namespace.\n   *\n   * @param {String} name - the namespace\n   * @param {Object} auth - the auth parameters\n   * @private\n   */\n  connect(name) {\n    let auth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (this.server._nsps.has(name)) {\n      debug(\"connecting to namespace %s\", name);\n      return this.doConnect(name, auth);\n    }\n    this.server._checkNamespace(name, auth, dynamicNspName => {\n      if (dynamicNspName) {\n        this.doConnect(name, auth);\n      } else {\n        debug(\"creation of namespace %s was denied\", name);\n        this._packet({\n          type: socket_io_parser_1.PacketType.CONNECT_ERROR,\n          nsp: name,\n          data: {\n            message: \"Invalid namespace\"\n          }\n        });\n      }\n    });\n  }\n  /**\n   * Connects a client to a namespace.\n   *\n   * @param name - the namespace\n   * @param {Object} auth - the auth parameters\n   *\n   * @private\n   */\n  doConnect(name, auth) {\n    const nsp = this.server.of(name);\n    const socket = nsp._add(this, auth, () => {\n      this.sockets.set(socket.id, socket);\n      this.nsps.set(nsp.name, socket);\n      if (this.connectTimeout) {\n        clearTimeout(this.connectTimeout);\n        this.connectTimeout = undefined;\n      }\n    });\n  }\n  /**\n   * Disconnects from all namespaces and closes transport.\n   *\n   * @private\n   */\n  _disconnect() {\n    for (const socket of this.sockets.values()) {\n      socket.disconnect();\n    }\n    this.sockets.clear();\n    this.close();\n  }\n  /**\n   * Removes a socket. Called by each `Socket`.\n   *\n   * @private\n   */\n  _remove(socket) {\n    if (this.sockets.has(socket.id)) {\n      const nsp = this.sockets.get(socket.id).nsp.name;\n      this.sockets.delete(socket.id);\n      this.nsps.delete(nsp);\n    } else {\n      debug(\"ignoring remove for %s\", socket.id);\n    }\n  }\n  /**\n   * Closes the underlying connection.\n   *\n   * @private\n   */\n  close() {\n    if (\"open\" === this.conn.readyState) {\n      debug(\"forcing transport close\");\n      this.conn.close();\n      this.onclose(\"forced server close\");\n    }\n  }\n  /**\n   * Writes a packet to the transport.\n   *\n   * @param {Object} packet object\n   * @param {Object} opts\n   * @private\n   */\n  _packet(packet) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (this.conn.readyState !== \"open\") {\n      debug(\"ignoring packet write %j\", packet);\n      return;\n    }\n    const encodedPackets = opts.preEncoded ? packet // previous versions of the adapter incorrectly used socket.packet() instead of writeToEngine()\n    : this.encoder.encode(packet);\n    this.writeToEngine(encodedPackets, opts);\n  }\n  writeToEngine(encodedPackets, opts) {\n    if (opts.volatile && !this.conn.transport.writable) {\n      debug(\"volatile packet is discarded since the transport is not currently writable\");\n      return;\n    }\n    const packets = Array.isArray(encodedPackets) ? encodedPackets : [encodedPackets];\n    for (const encodedPacket of packets) {\n      this.conn.write(encodedPacket, opts);\n    }\n  }\n  /**\n   * Called with incoming transport data.\n   *\n   * @private\n   */\n  ondata(data) {\n    // try/catch is needed for protocol violations (GH-1880)\n    try {\n      this.decoder.add(data);\n    } catch (e) {\n      debug(\"invalid packet format\");\n      this.onerror(e);\n    }\n  }\n  /**\n   * Called when parser fully decodes a packet.\n   *\n   * @private\n   */\n  ondecoded(packet) {\n    let namespace;\n    let authPayload;\n    if (this.conn.protocol === 3) {\n      const parsed = url.parse(packet.nsp, true);\n      namespace = parsed.pathname;\n      authPayload = parsed.query;\n    } else {\n      namespace = packet.nsp;\n      authPayload = packet.data;\n    }\n    const socket = this.nsps.get(namespace);\n    if (!socket && packet.type === socket_io_parser_1.PacketType.CONNECT) {\n      this.connect(namespace, authPayload);\n    } else if (socket && packet.type !== socket_io_parser_1.PacketType.CONNECT && packet.type !== socket_io_parser_1.PacketType.CONNECT_ERROR) {\n      process.nextTick(function () {\n        socket._onpacket(packet);\n      });\n    } else {\n      debug(\"invalid state (packet type: %s)\", packet.type);\n      this.close();\n    }\n  }\n  /**\n   * Handles an error.\n   *\n   * @param {Object} err object\n   * @private\n   */\n  onerror(err) {\n    for (const socket of this.sockets.values()) {\n      socket._onerror(err);\n    }\n    this.conn.close();\n  }\n  /**\n   * Called upon transport close.\n   *\n   * @param reason\n   * @private\n   */\n  onclose(reason) {\n    debug(\"client close with reason %s\", reason);\n    // ignore a potential subsequent `close` event\n    this.destroy();\n    // `nsps` and `sockets` are cleaned up seamlessly\n    for (const socket of this.sockets.values()) {\n      socket._onclose(reason);\n    }\n    this.sockets.clear();\n    this.decoder.destroy(); // clean up decoder\n  }\n  /**\n   * Cleans up event listeners.\n   * @private\n   */\n  destroy() {\n    this.conn.removeListener(\"data\", this.ondata);\n    this.conn.removeListener(\"error\", this.onerror);\n    this.conn.removeListener(\"close\", this.onclose);\n    // @ts-ignore\n    this.decoder.removeListener(\"decoded\", this.ondecoded);\n    if (this.connectTimeout) {\n      clearTimeout(this.connectTimeout);\n      this.connectTimeout = undefined;\n    }\n  }\n}\nexports.Client = Client;","map":{"version":3,"names":["Object","defineProperty","exports","value","Client","socket_io_parser_1","require","debugModule","url","debug","constructor","server","conn","sockets","Map","nsps","encoder","decoder","_parser","Decoder","id","setup","request","onclose","bind","ondata","onerror","ondecoded","on","connectTimeout","setTimeout","size","close","_connectTimeout","connect","name","auth","_nsps","has","doConnect","_checkNamespace","dynamicNspName","_packet","type","PacketType","CONNECT_ERROR","nsp","data","message","of","socket","_add","set","clearTimeout","undefined","_disconnect","values","disconnect","clear","_remove","get","delete","readyState","packet","opts","encodedPackets","preEncoded","encode","writeToEngine","volatile","transport","writable","packets","Array","isArray","encodedPacket","write","add","e","namespace","authPayload","protocol","parsed","parse","pathname","query","CONNECT","process","nextTick","_onpacket","err","_onerror","reason","destroy","_onclose","removeListener"],"sources":["/home/samuel/Documents/chatApp/node_modules/socket.io/dist/client.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Client = void 0;\nconst socket_io_parser_1 = require(\"socket.io-parser\");\nconst debugModule = require(\"debug\");\nconst url = require(\"url\");\nconst debug = debugModule(\"socket.io:client\");\nclass Client {\n    /**\n     * Client constructor.\n     *\n     * @param server instance\n     * @param conn\n     * @package\n     */\n    constructor(server, conn) {\n        this.sockets = new Map();\n        this.nsps = new Map();\n        this.server = server;\n        this.conn = conn;\n        this.encoder = server.encoder;\n        this.decoder = new server._parser.Decoder();\n        this.id = conn.id;\n        this.setup();\n    }\n    /**\n     * @return the reference to the request that originated the Engine.IO connection\n     *\n     * @public\n     */\n    get request() {\n        return this.conn.request;\n    }\n    /**\n     * Sets up event listeners.\n     *\n     * @private\n     */\n    setup() {\n        this.onclose = this.onclose.bind(this);\n        this.ondata = this.ondata.bind(this);\n        this.onerror = this.onerror.bind(this);\n        this.ondecoded = this.ondecoded.bind(this);\n        // @ts-ignore\n        this.decoder.on(\"decoded\", this.ondecoded);\n        this.conn.on(\"data\", this.ondata);\n        this.conn.on(\"error\", this.onerror);\n        this.conn.on(\"close\", this.onclose);\n        this.connectTimeout = setTimeout(() => {\n            if (this.nsps.size === 0) {\n                debug(\"no namespace joined yet, close the client\");\n                this.close();\n            }\n            else {\n                debug(\"the client has already joined a namespace, nothing to do\");\n            }\n        }, this.server._connectTimeout);\n    }\n    /**\n     * Connects a client to a namespace.\n     *\n     * @param {String} name - the namespace\n     * @param {Object} auth - the auth parameters\n     * @private\n     */\n    connect(name, auth = {}) {\n        if (this.server._nsps.has(name)) {\n            debug(\"connecting to namespace %s\", name);\n            return this.doConnect(name, auth);\n        }\n        this.server._checkNamespace(name, auth, (dynamicNspName) => {\n            if (dynamicNspName) {\n                this.doConnect(name, auth);\n            }\n            else {\n                debug(\"creation of namespace %s was denied\", name);\n                this._packet({\n                    type: socket_io_parser_1.PacketType.CONNECT_ERROR,\n                    nsp: name,\n                    data: {\n                        message: \"Invalid namespace\",\n                    },\n                });\n            }\n        });\n    }\n    /**\n     * Connects a client to a namespace.\n     *\n     * @param name - the namespace\n     * @param {Object} auth - the auth parameters\n     *\n     * @private\n     */\n    doConnect(name, auth) {\n        const nsp = this.server.of(name);\n        const socket = nsp._add(this, auth, () => {\n            this.sockets.set(socket.id, socket);\n            this.nsps.set(nsp.name, socket);\n            if (this.connectTimeout) {\n                clearTimeout(this.connectTimeout);\n                this.connectTimeout = undefined;\n            }\n        });\n    }\n    /**\n     * Disconnects from all namespaces and closes transport.\n     *\n     * @private\n     */\n    _disconnect() {\n        for (const socket of this.sockets.values()) {\n            socket.disconnect();\n        }\n        this.sockets.clear();\n        this.close();\n    }\n    /**\n     * Removes a socket. Called by each `Socket`.\n     *\n     * @private\n     */\n    _remove(socket) {\n        if (this.sockets.has(socket.id)) {\n            const nsp = this.sockets.get(socket.id).nsp.name;\n            this.sockets.delete(socket.id);\n            this.nsps.delete(nsp);\n        }\n        else {\n            debug(\"ignoring remove for %s\", socket.id);\n        }\n    }\n    /**\n     * Closes the underlying connection.\n     *\n     * @private\n     */\n    close() {\n        if (\"open\" === this.conn.readyState) {\n            debug(\"forcing transport close\");\n            this.conn.close();\n            this.onclose(\"forced server close\");\n        }\n    }\n    /**\n     * Writes a packet to the transport.\n     *\n     * @param {Object} packet object\n     * @param {Object} opts\n     * @private\n     */\n    _packet(packet, opts = {}) {\n        if (this.conn.readyState !== \"open\") {\n            debug(\"ignoring packet write %j\", packet);\n            return;\n        }\n        const encodedPackets = opts.preEncoded\n            ? packet // previous versions of the adapter incorrectly used socket.packet() instead of writeToEngine()\n            : this.encoder.encode(packet);\n        this.writeToEngine(encodedPackets, opts);\n    }\n    writeToEngine(encodedPackets, opts) {\n        if (opts.volatile && !this.conn.transport.writable) {\n            debug(\"volatile packet is discarded since the transport is not currently writable\");\n            return;\n        }\n        const packets = Array.isArray(encodedPackets)\n            ? encodedPackets\n            : [encodedPackets];\n        for (const encodedPacket of packets) {\n            this.conn.write(encodedPacket, opts);\n        }\n    }\n    /**\n     * Called with incoming transport data.\n     *\n     * @private\n     */\n    ondata(data) {\n        // try/catch is needed for protocol violations (GH-1880)\n        try {\n            this.decoder.add(data);\n        }\n        catch (e) {\n            debug(\"invalid packet format\");\n            this.onerror(e);\n        }\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */\n    ondecoded(packet) {\n        let namespace;\n        let authPayload;\n        if (this.conn.protocol === 3) {\n            const parsed = url.parse(packet.nsp, true);\n            namespace = parsed.pathname;\n            authPayload = parsed.query;\n        }\n        else {\n            namespace = packet.nsp;\n            authPayload = packet.data;\n        }\n        const socket = this.nsps.get(namespace);\n        if (!socket && packet.type === socket_io_parser_1.PacketType.CONNECT) {\n            this.connect(namespace, authPayload);\n        }\n        else if (socket &&\n            packet.type !== socket_io_parser_1.PacketType.CONNECT &&\n            packet.type !== socket_io_parser_1.PacketType.CONNECT_ERROR) {\n            process.nextTick(function () {\n                socket._onpacket(packet);\n            });\n        }\n        else {\n            debug(\"invalid state (packet type: %s)\", packet.type);\n            this.close();\n        }\n    }\n    /**\n     * Handles an error.\n     *\n     * @param {Object} err object\n     * @private\n     */\n    onerror(err) {\n        for (const socket of this.sockets.values()) {\n            socket._onerror(err);\n        }\n        this.conn.close();\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @param reason\n     * @private\n     */\n    onclose(reason) {\n        debug(\"client close with reason %s\", reason);\n        // ignore a potential subsequent `close` event\n        this.destroy();\n        // `nsps` and `sockets` are cleaned up seamlessly\n        for (const socket of this.sockets.values()) {\n            socket._onclose(reason);\n        }\n        this.sockets.clear();\n        this.decoder.destroy(); // clean up decoder\n    }\n    /**\n     * Cleans up event listeners.\n     * @private\n     */\n    destroy() {\n        this.conn.removeListener(\"data\", this.ondata);\n        this.conn.removeListener(\"error\", this.onerror);\n        this.conn.removeListener(\"close\", this.onclose);\n        // @ts-ignore\n        this.decoder.removeListener(\"decoded\", this.ondecoded);\n        if (this.connectTimeout) {\n            clearTimeout(this.connectTimeout);\n            this.connectTimeout = undefined;\n        }\n    }\n}\nexports.Client = Client;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}