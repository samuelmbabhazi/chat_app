{"ast":null,"code":"\"use strict\";\n\n// imported from https://github.com/socketio/engine.io-parser/tree/2.2.x\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodePayloadAsBinary = exports.encodePayloadAsBinary = exports.decodePayload = exports.encodePayload = exports.decodeBase64Packet = exports.decodePacket = exports.encodeBase64Packet = exports.encodePacket = exports.packets = exports.protocol = void 0;\n/**\n * Module dependencies.\n */\nvar utf8 = require('./utf8');\n/**\n * Current protocol version.\n */\nexports.protocol = 3;\nconst hasBinary = packets => {\n  for (const packet of packets) {\n    if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {\n      return true;\n    }\n  }\n  return false;\n};\n/**\n * Packet types.\n */\nexports.packets = {\n  open: 0 // non-ws\n  ,\n\n  close: 1 // non-ws\n  ,\n\n  ping: 2,\n  pong: 3,\n  message: 4,\n  upgrade: 5,\n  noop: 6\n};\nvar packetslist = Object.keys(exports.packets);\n/**\n * Premade error packet.\n */\nvar err = {\n  type: 'error',\n  data: 'parser error'\n};\nconst EMPTY_BUFFER = Buffer.concat([]);\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */\nfunction encodePacket(packet, supportsBinary, utf8encode, callback) {\n  if (typeof supportsBinary === 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n  if (typeof utf8encode === 'function') {\n    callback = utf8encode;\n    utf8encode = null;\n  }\n  if (Buffer.isBuffer(packet.data)) {\n    return encodeBuffer(packet, supportsBinary, callback);\n  } else if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) {\n    return encodeBuffer({\n      type: packet.type,\n      data: arrayBufferToBuffer(packet.data)\n    }, supportsBinary, callback);\n  }\n  // Sending data as a utf-8 string\n  var encoded = exports.packets[packet.type];\n  // data fragment is optional\n  if (undefined !== packet.data) {\n    encoded += utf8encode ? utf8.encode(String(packet.data), {\n      strict: false\n    }) : String(packet.data);\n  }\n  return callback('' + encoded);\n}\nexports.encodePacket = encodePacket;\n;\n/**\n * Encode Buffer data\n */\nfunction encodeBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return encodeBase64Packet(packet, callback);\n  }\n  var data = packet.data;\n  var typeBuffer = Buffer.allocUnsafe(1);\n  typeBuffer[0] = exports.packets[packet.type];\n  return callback(Buffer.concat([typeBuffer, data]));\n}\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */\nfunction encodeBase64Packet(packet, callback) {\n  var data = Buffer.isBuffer(packet.data) ? packet.data : arrayBufferToBuffer(packet.data);\n  var message = 'b' + exports.packets[packet.type];\n  message += data.toString('base64');\n  return callback(message);\n}\nexports.encodeBase64Packet = encodeBase64Packet;\n;\n/**\n * Decodes a packet. Data also available as an ArrayBuffer if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */\nfunction decodePacket(data, binaryType, utf8decode) {\n  if (data === undefined) {\n    return err;\n  }\n  var type;\n  // String data\n  if (typeof data === 'string') {\n    type = data.charAt(0);\n    if (type === 'b') {\n      return decodeBase64Packet(data.substr(1), binaryType);\n    }\n    if (utf8decode) {\n      data = tryDecode(data);\n      if (data === false) {\n        return err;\n      }\n    }\n    if (Number(type) != type || !packetslist[type]) {\n      return err;\n    }\n    if (data.length > 1) {\n      return {\n        type: packetslist[type],\n        data: data.substring(1)\n      };\n    } else {\n      return {\n        type: packetslist[type]\n      };\n    }\n  }\n  // Binary data\n  if (binaryType === 'arraybuffer') {\n    // wrap Buffer/ArrayBuffer data into an Uint8Array\n    var intArray = new Uint8Array(data);\n    type = intArray[0];\n    return {\n      type: packetslist[type],\n      data: intArray.buffer.slice(1)\n    };\n  }\n  if (data instanceof ArrayBuffer) {\n    data = arrayBufferToBuffer(data);\n  }\n  type = data[0];\n  return {\n    type: packetslist[type],\n    data: data.slice(1)\n  };\n}\nexports.decodePacket = decodePacket;\n;\nfunction tryDecode(data) {\n  try {\n    data = utf8.decode(data, {\n      strict: false\n    });\n  } catch (e) {\n    return false;\n  }\n  return data;\n}\n/**\n * Decodes a packet encoded in a base64 string.\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */\nfunction decodeBase64Packet(msg, binaryType) {\n  var type = packetslist[msg.charAt(0)];\n  var data = Buffer.from(msg.substr(1), 'base64');\n  if (binaryType === 'arraybuffer') {\n    var abv = new Uint8Array(data.length);\n    for (var i = 0; i < abv.length; i++) {\n      abv[i] = data[i];\n    }\n    // @ts-ignore\n    data = abv.buffer;\n  }\n  return {\n    type: type,\n    data: data\n  };\n}\nexports.decodeBase64Packet = decodeBase64Packet;\n;\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */\nfunction encodePayload(packets, supportsBinary, callback) {\n  if (typeof supportsBinary === 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n  if (supportsBinary && hasBinary(packets)) {\n    return encodePayloadAsBinary(packets, callback);\n  }\n  if (!packets.length) {\n    return callback('0:');\n  }\n  function encodeOne(packet, doneCallback) {\n    encodePacket(packet, supportsBinary, false, function (message) {\n      doneCallback(null, setLengthHeader(message));\n    });\n  }\n  map(packets, encodeOne, function (err, results) {\n    return callback(results.join(''));\n  });\n}\nexports.encodePayload = encodePayload;\n;\nfunction setLengthHeader(message) {\n  return message.length + ':' + message;\n}\n/**\n * Async array map using after\n */\nfunction map(ary, each, done) {\n  const results = new Array(ary.length);\n  let count = 0;\n  for (let i = 0; i < ary.length; i++) {\n    each(ary[i], (error, msg) => {\n      results[i] = msg;\n      if (++count === ary.length) {\n        done(null, results);\n      }\n    });\n  }\n}\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */\nfunction decodePayload(data, binaryType, callback) {\n  if (typeof data !== 'string') {\n    return decodePayloadAsBinary(data, binaryType, callback);\n  }\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n  if (data === '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n  var length = '',\n    n,\n    msg,\n    packet;\n  for (var i = 0, l = data.length; i < l; i++) {\n    var chr = data.charAt(i);\n    if (chr !== ':') {\n      length += chr;\n      continue;\n    }\n    // @ts-ignore\n    if (length === '' || length != (n = Number(length))) {\n      // parser error - ignoring payload\n      return callback(err, 0, 1);\n    }\n    msg = data.substr(i + 1, n);\n    if (length != msg.length) {\n      // parser error - ignoring payload\n      return callback(err, 0, 1);\n    }\n    if (msg.length) {\n      packet = decodePacket(msg, binaryType, false);\n      if (err.type === packet.type && err.data === packet.data) {\n        // parser error in individual packet - ignoring payload\n        return callback(err, 0, 1);\n      }\n      var more = callback(packet, i + n, l);\n      if (false === more) return;\n    }\n    // advance cursor\n    i += n;\n    length = '';\n  }\n  if (length !== '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n}\nexports.decodePayload = decodePayload;\n;\n/**\n *\n * Converts a buffer to a utf8.js encoded string\n *\n * @api private\n */\nfunction bufferToString(buffer) {\n  var str = '';\n  for (var i = 0, l = buffer.length; i < l; i++) {\n    str += String.fromCharCode(buffer[i]);\n  }\n  return str;\n}\n/**\n *\n * Converts a utf8.js encoded string to a buffer\n *\n * @api private\n */\nfunction stringToBuffer(string) {\n  var buf = Buffer.allocUnsafe(string.length);\n  for (var i = 0, l = string.length; i < l; i++) {\n    buf.writeUInt8(string.charCodeAt(i), i);\n  }\n  return buf;\n}\n/**\n *\n * Converts an ArrayBuffer to a Buffer\n *\n * @api private\n */\nfunction arrayBufferToBuffer(data) {\n  // data is either an ArrayBuffer or ArrayBufferView.\n  var length = data.byteLength || data.length;\n  var offset = data.byteOffset || 0;\n  return Buffer.from(data.buffer || data, offset, length);\n}\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {Buffer} encoded payload\n * @api private\n */\nfunction encodePayloadAsBinary(packets, callback) {\n  if (!packets.length) {\n    return callback(EMPTY_BUFFER);\n  }\n  map(packets, encodeOneBinaryPacket, function (err, results) {\n    return callback(Buffer.concat(results));\n  });\n}\nexports.encodePayloadAsBinary = encodePayloadAsBinary;\n;\nfunction encodeOneBinaryPacket(p, doneCallback) {\n  function onBinaryPacketEncode(packet) {\n    var encodingLength = '' + packet.length;\n    var sizeBuffer;\n    if (typeof packet === 'string') {\n      sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);\n      sizeBuffer[0] = 0; // is a string (not true binary = 0)\n      for (var i = 0; i < encodingLength.length; i++) {\n        sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\n      }\n      sizeBuffer[sizeBuffer.length - 1] = 255;\n      return doneCallback(null, Buffer.concat([sizeBuffer, stringToBuffer(packet)]));\n    }\n    sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);\n    sizeBuffer[0] = 1; // is binary (true binary = 1)\n    for (var i = 0; i < encodingLength.length; i++) {\n      sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\n    }\n    sizeBuffer[sizeBuffer.length - 1] = 255;\n    doneCallback(null, Buffer.concat([sizeBuffer, packet]));\n  }\n  encodePacket(p, true, true, onBinaryPacketEncode);\n}\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n\n * @param {Buffer} data, callback method\n * @api public\n */\nfunction decodePayloadAsBinary(data, binaryType, callback) {\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n  var bufferTail = data;\n  var buffers = [];\n  var i;\n  while (bufferTail.length > 0) {\n    var strLen = '';\n    var isString = bufferTail[0] === 0;\n    for (i = 1;; i++) {\n      if (bufferTail[i] === 255) break;\n      // 310 = char length of Number.MAX_VALUE\n      if (strLen.length > 310) {\n        return callback(err, 0, 1);\n      }\n      strLen += '' + bufferTail[i];\n    }\n    bufferTail = bufferTail.slice(strLen.length + 1);\n    var msgLength = parseInt(strLen, 10);\n    var msg = bufferTail.slice(1, msgLength + 1);\n    if (isString) msg = bufferToString(msg);\n    buffers.push(msg);\n    bufferTail = bufferTail.slice(msgLength + 1);\n  }\n  var total = buffers.length;\n  for (i = 0; i < total; i++) {\n    var buffer = buffers[i];\n    callback(decodePacket(buffer, binaryType, true), i, total);\n  }\n}\nexports.decodePayloadAsBinary = decodePayloadAsBinary;\n;","map":{"version":3,"names":["Object","defineProperty","exports","value","decodePayloadAsBinary","encodePayloadAsBinary","decodePayload","encodePayload","decodeBase64Packet","decodePacket","encodeBase64Packet","encodePacket","packets","protocol","utf8","require","hasBinary","packet","data","ArrayBuffer","isView","open","close","ping","pong","message","upgrade","noop","packetslist","keys","err","type","EMPTY_BUFFER","Buffer","concat","supportsBinary","utf8encode","callback","isBuffer","encodeBuffer","buffer","arrayBufferToBuffer","encoded","undefined","encode","String","strict","typeBuffer","allocUnsafe","toString","binaryType","utf8decode","charAt","substr","tryDecode","Number","length","substring","intArray","Uint8Array","slice","decode","e","msg","from","abv","i","encodeOne","doneCallback","setLengthHeader","map","results","join","ary","each","done","Array","count","error","n","l","chr","more","bufferToString","str","fromCharCode","stringToBuffer","string","buf","writeUInt8","charCodeAt","byteLength","offset","byteOffset","encodeOneBinaryPacket","p","onBinaryPacketEncode","encodingLength","sizeBuffer","parseInt","bufferTail","buffers","strLen","isString","msgLength","push","total"],"sources":["/home/samuel/Documents/chatApp/node_modules/engine.io/build/parser-v3/index.js"],"sourcesContent":["\"use strict\";\n// imported from https://github.com/socketio/engine.io-parser/tree/2.2.x\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodePayloadAsBinary = exports.encodePayloadAsBinary = exports.decodePayload = exports.encodePayload = exports.decodeBase64Packet = exports.decodePacket = exports.encodeBase64Packet = exports.encodePacket = exports.packets = exports.protocol = void 0;\n/**\n * Module dependencies.\n */\nvar utf8 = require('./utf8');\n/**\n * Current protocol version.\n */\nexports.protocol = 3;\nconst hasBinary = (packets) => {\n    for (const packet of packets) {\n        if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {\n            return true;\n        }\n    }\n    return false;\n};\n/**\n * Packet types.\n */\nexports.packets = {\n    open: 0 // non-ws\n    ,\n    close: 1 // non-ws\n    ,\n    ping: 2,\n    pong: 3,\n    message: 4,\n    upgrade: 5,\n    noop: 6\n};\nvar packetslist = Object.keys(exports.packets);\n/**\n * Premade error packet.\n */\nvar err = { type: 'error', data: 'parser error' };\nconst EMPTY_BUFFER = Buffer.concat([]);\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */\nfunction encodePacket(packet, supportsBinary, utf8encode, callback) {\n    if (typeof supportsBinary === 'function') {\n        callback = supportsBinary;\n        supportsBinary = null;\n    }\n    if (typeof utf8encode === 'function') {\n        callback = utf8encode;\n        utf8encode = null;\n    }\n    if (Buffer.isBuffer(packet.data)) {\n        return encodeBuffer(packet, supportsBinary, callback);\n    }\n    else if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) {\n        return encodeBuffer({ type: packet.type, data: arrayBufferToBuffer(packet.data) }, supportsBinary, callback);\n    }\n    // Sending data as a utf-8 string\n    var encoded = exports.packets[packet.type];\n    // data fragment is optional\n    if (undefined !== packet.data) {\n        encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);\n    }\n    return callback('' + encoded);\n}\nexports.encodePacket = encodePacket;\n;\n/**\n * Encode Buffer data\n */\nfunction encodeBuffer(packet, supportsBinary, callback) {\n    if (!supportsBinary) {\n        return encodeBase64Packet(packet, callback);\n    }\n    var data = packet.data;\n    var typeBuffer = Buffer.allocUnsafe(1);\n    typeBuffer[0] = exports.packets[packet.type];\n    return callback(Buffer.concat([typeBuffer, data]));\n}\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */\nfunction encodeBase64Packet(packet, callback) {\n    var data = Buffer.isBuffer(packet.data) ? packet.data : arrayBufferToBuffer(packet.data);\n    var message = 'b' + exports.packets[packet.type];\n    message += data.toString('base64');\n    return callback(message);\n}\nexports.encodeBase64Packet = encodeBase64Packet;\n;\n/**\n * Decodes a packet. Data also available as an ArrayBuffer if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */\nfunction decodePacket(data, binaryType, utf8decode) {\n    if (data === undefined) {\n        return err;\n    }\n    var type;\n    // String data\n    if (typeof data === 'string') {\n        type = data.charAt(0);\n        if (type === 'b') {\n            return decodeBase64Packet(data.substr(1), binaryType);\n        }\n        if (utf8decode) {\n            data = tryDecode(data);\n            if (data === false) {\n                return err;\n            }\n        }\n        if (Number(type) != type || !packetslist[type]) {\n            return err;\n        }\n        if (data.length > 1) {\n            return { type: packetslist[type], data: data.substring(1) };\n        }\n        else {\n            return { type: packetslist[type] };\n        }\n    }\n    // Binary data\n    if (binaryType === 'arraybuffer') {\n        // wrap Buffer/ArrayBuffer data into an Uint8Array\n        var intArray = new Uint8Array(data);\n        type = intArray[0];\n        return { type: packetslist[type], data: intArray.buffer.slice(1) };\n    }\n    if (data instanceof ArrayBuffer) {\n        data = arrayBufferToBuffer(data);\n    }\n    type = data[0];\n    return { type: packetslist[type], data: data.slice(1) };\n}\nexports.decodePacket = decodePacket;\n;\nfunction tryDecode(data) {\n    try {\n        data = utf8.decode(data, { strict: false });\n    }\n    catch (e) {\n        return false;\n    }\n    return data;\n}\n/**\n * Decodes a packet encoded in a base64 string.\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */\nfunction decodeBase64Packet(msg, binaryType) {\n    var type = packetslist[msg.charAt(0)];\n    var data = Buffer.from(msg.substr(1), 'base64');\n    if (binaryType === 'arraybuffer') {\n        var abv = new Uint8Array(data.length);\n        for (var i = 0; i < abv.length; i++) {\n            abv[i] = data[i];\n        }\n        // @ts-ignore\n        data = abv.buffer;\n    }\n    return { type: type, data: data };\n}\nexports.decodeBase64Packet = decodeBase64Packet;\n;\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */\nfunction encodePayload(packets, supportsBinary, callback) {\n    if (typeof supportsBinary === 'function') {\n        callback = supportsBinary;\n        supportsBinary = null;\n    }\n    if (supportsBinary && hasBinary(packets)) {\n        return encodePayloadAsBinary(packets, callback);\n    }\n    if (!packets.length) {\n        return callback('0:');\n    }\n    function encodeOne(packet, doneCallback) {\n        encodePacket(packet, supportsBinary, false, function (message) {\n            doneCallback(null, setLengthHeader(message));\n        });\n    }\n    map(packets, encodeOne, function (err, results) {\n        return callback(results.join(''));\n    });\n}\nexports.encodePayload = encodePayload;\n;\nfunction setLengthHeader(message) {\n    return message.length + ':' + message;\n}\n/**\n * Async array map using after\n */\nfunction map(ary, each, done) {\n    const results = new Array(ary.length);\n    let count = 0;\n    for (let i = 0; i < ary.length; i++) {\n        each(ary[i], (error, msg) => {\n            results[i] = msg;\n            if (++count === ary.length) {\n                done(null, results);\n            }\n        });\n    }\n}\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */\nfunction decodePayload(data, binaryType, callback) {\n    if (typeof data !== 'string') {\n        return decodePayloadAsBinary(data, binaryType, callback);\n    }\n    if (typeof binaryType === 'function') {\n        callback = binaryType;\n        binaryType = null;\n    }\n    if (data === '') {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n    }\n    var length = '', n, msg, packet;\n    for (var i = 0, l = data.length; i < l; i++) {\n        var chr = data.charAt(i);\n        if (chr !== ':') {\n            length += chr;\n            continue;\n        }\n        // @ts-ignore\n        if (length === '' || (length != (n = Number(length)))) {\n            // parser error - ignoring payload\n            return callback(err, 0, 1);\n        }\n        msg = data.substr(i + 1, n);\n        if (length != msg.length) {\n            // parser error - ignoring payload\n            return callback(err, 0, 1);\n        }\n        if (msg.length) {\n            packet = decodePacket(msg, binaryType, false);\n            if (err.type === packet.type && err.data === packet.data) {\n                // parser error in individual packet - ignoring payload\n                return callback(err, 0, 1);\n            }\n            var more = callback(packet, i + n, l);\n            if (false === more)\n                return;\n        }\n        // advance cursor\n        i += n;\n        length = '';\n    }\n    if (length !== '') {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n    }\n}\nexports.decodePayload = decodePayload;\n;\n/**\n *\n * Converts a buffer to a utf8.js encoded string\n *\n * @api private\n */\nfunction bufferToString(buffer) {\n    var str = '';\n    for (var i = 0, l = buffer.length; i < l; i++) {\n        str += String.fromCharCode(buffer[i]);\n    }\n    return str;\n}\n/**\n *\n * Converts a utf8.js encoded string to a buffer\n *\n * @api private\n */\nfunction stringToBuffer(string) {\n    var buf = Buffer.allocUnsafe(string.length);\n    for (var i = 0, l = string.length; i < l; i++) {\n        buf.writeUInt8(string.charCodeAt(i), i);\n    }\n    return buf;\n}\n/**\n *\n * Converts an ArrayBuffer to a Buffer\n *\n * @api private\n */\nfunction arrayBufferToBuffer(data) {\n    // data is either an ArrayBuffer or ArrayBufferView.\n    var length = data.byteLength || data.length;\n    var offset = data.byteOffset || 0;\n    return Buffer.from(data.buffer || data, offset, length);\n}\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {Buffer} encoded payload\n * @api private\n */\nfunction encodePayloadAsBinary(packets, callback) {\n    if (!packets.length) {\n        return callback(EMPTY_BUFFER);\n    }\n    map(packets, encodeOneBinaryPacket, function (err, results) {\n        return callback(Buffer.concat(results));\n    });\n}\nexports.encodePayloadAsBinary = encodePayloadAsBinary;\n;\nfunction encodeOneBinaryPacket(p, doneCallback) {\n    function onBinaryPacketEncode(packet) {\n        var encodingLength = '' + packet.length;\n        var sizeBuffer;\n        if (typeof packet === 'string') {\n            sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);\n            sizeBuffer[0] = 0; // is a string (not true binary = 0)\n            for (var i = 0; i < encodingLength.length; i++) {\n                sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\n            }\n            sizeBuffer[sizeBuffer.length - 1] = 255;\n            return doneCallback(null, Buffer.concat([sizeBuffer, stringToBuffer(packet)]));\n        }\n        sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);\n        sizeBuffer[0] = 1; // is binary (true binary = 1)\n        for (var i = 0; i < encodingLength.length; i++) {\n            sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\n        }\n        sizeBuffer[sizeBuffer.length - 1] = 255;\n        doneCallback(null, Buffer.concat([sizeBuffer, packet]));\n    }\n    encodePacket(p, true, true, onBinaryPacketEncode);\n}\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n\n * @param {Buffer} data, callback method\n * @api public\n */\nfunction decodePayloadAsBinary(data, binaryType, callback) {\n    if (typeof binaryType === 'function') {\n        callback = binaryType;\n        binaryType = null;\n    }\n    var bufferTail = data;\n    var buffers = [];\n    var i;\n    while (bufferTail.length > 0) {\n        var strLen = '';\n        var isString = bufferTail[0] === 0;\n        for (i = 1;; i++) {\n            if (bufferTail[i] === 255)\n                break;\n            // 310 = char length of Number.MAX_VALUE\n            if (strLen.length > 310) {\n                return callback(err, 0, 1);\n            }\n            strLen += '' + bufferTail[i];\n        }\n        bufferTail = bufferTail.slice(strLen.length + 1);\n        var msgLength = parseInt(strLen, 10);\n        var msg = bufferTail.slice(1, msgLength + 1);\n        if (isString)\n            msg = bufferToString(msg);\n        buffers.push(msg);\n        bufferTail = bufferTail.slice(msgLength + 1);\n    }\n    var total = buffers.length;\n    for (i = 0; i < total; i++) {\n        var buffer = buffers[i];\n        callback(decodePacket(buffer, binaryType, true), i, total);\n    }\n}\nexports.decodePayloadAsBinary = decodePayloadAsBinary;\n;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}