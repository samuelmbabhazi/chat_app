{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParentNamespace = void 0;\nconst namespace_1 = require(\"./namespace\");\nclass ParentNamespace extends namespace_1.Namespace {\n  constructor(server) {\n    super(server, \"/_\" + ParentNamespace.count++);\n    this.children = new Set();\n  }\n  /**\n   * @private\n   */\n  _initAdapter() {\n    const broadcast = (packet, opts) => {\n      this.children.forEach(nsp => {\n        nsp.adapter.broadcast(packet, opts);\n      });\n    };\n    // @ts-ignore FIXME is there a way to declare an inner class in TypeScript?\n    this.adapter = {\n      broadcast\n    };\n  }\n  emit(ev) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    this.children.forEach(nsp => {\n      nsp.emit(ev, ...args);\n    });\n    return true;\n  }\n  createChild(name) {\n    const namespace = new namespace_1.Namespace(this.server, name);\n    namespace._fns = this._fns.slice(0);\n    this.listeners(\"connect\").forEach(listener => namespace.on(\"connect\", listener));\n    this.listeners(\"connection\").forEach(listener => namespace.on(\"connection\", listener));\n    this.children.add(namespace);\n    this.server._nsps.set(name, namespace);\n    return namespace;\n  }\n  fetchSockets() {\n    // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the\n    // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but\n    // the behavior for namespaces created with a function is less clear\n    // note²: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace\n    // may exist on one node but not exist on another (since it is created upon client connection)\n    throw new Error(\"fetchSockets() is not supported on parent namespaces\");\n  }\n}\nexports.ParentNamespace = ParentNamespace;\nParentNamespace.count = 0;","map":{"version":3,"names":["Object","defineProperty","exports","value","ParentNamespace","namespace_1","require","Namespace","constructor","server","count","children","Set","_initAdapter","broadcast","packet","opts","forEach","nsp","adapter","emit","ev","args","createChild","name","namespace","_fns","slice","listeners","listener","on","add","_nsps","set","fetchSockets","Error"],"sources":["/home/samuel/Documents/chatApp/node_modules/socket.io/dist/parent-namespace.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParentNamespace = void 0;\nconst namespace_1 = require(\"./namespace\");\nclass ParentNamespace extends namespace_1.Namespace {\n    constructor(server) {\n        super(server, \"/_\" + ParentNamespace.count++);\n        this.children = new Set();\n    }\n    /**\n     * @private\n     */\n    _initAdapter() {\n        const broadcast = (packet, opts) => {\n            this.children.forEach((nsp) => {\n                nsp.adapter.broadcast(packet, opts);\n            });\n        };\n        // @ts-ignore FIXME is there a way to declare an inner class in TypeScript?\n        this.adapter = { broadcast };\n    }\n    emit(ev, ...args) {\n        this.children.forEach((nsp) => {\n            nsp.emit(ev, ...args);\n        });\n        return true;\n    }\n    createChild(name) {\n        const namespace = new namespace_1.Namespace(this.server, name);\n        namespace._fns = this._fns.slice(0);\n        this.listeners(\"connect\").forEach((listener) => namespace.on(\"connect\", listener));\n        this.listeners(\"connection\").forEach((listener) => namespace.on(\"connection\", listener));\n        this.children.add(namespace);\n        this.server._nsps.set(name, namespace);\n        return namespace;\n    }\n    fetchSockets() {\n        // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the\n        // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but\n        // the behavior for namespaces created with a function is less clear\n        // note²: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace\n        // may exist on one node but not exist on another (since it is created upon client connection)\n        throw new Error(\"fetchSockets() is not supported on parent namespaces\");\n    }\n}\nexports.ParentNamespace = ParentNamespace;\nParentNamespace.count = 0;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,eAAe,GAAG,KAAK,CAAC;AAChC,MAAMC,WAAW,GAAGC,OAAO,CAAC,aAAa,CAAC;AAC1C,MAAMF,eAAe,SAASC,WAAW,CAACE,SAAS,CAAC;EAChDC,WAAW,CAACC,MAAM,EAAE;IAChB,KAAK,CAACA,MAAM,EAAE,IAAI,GAAGL,eAAe,CAACM,KAAK,EAAE,CAAC;IAC7C,IAAI,CAACC,QAAQ,GAAG,IAAIC,GAAG,EAAE;EAC7B;EACA;AACJ;AACA;EACIC,YAAY,GAAG;IACX,MAAMC,SAAS,GAAG,CAACC,MAAM,EAAEC,IAAI,KAAK;MAChC,IAAI,CAACL,QAAQ,CAACM,OAAO,CAAEC,GAAG,IAAK;QAC3BA,GAAG,CAACC,OAAO,CAACL,SAAS,CAACC,MAAM,EAAEC,IAAI,CAAC;MACvC,CAAC,CAAC;IACN,CAAC;IACD;IACA,IAAI,CAACG,OAAO,GAAG;MAAEL;IAAU,CAAC;EAChC;EACAM,IAAI,CAACC,EAAE,EAAW;IAAA,kCAANC,IAAI;MAAJA,IAAI;IAAA;IACZ,IAAI,CAACX,QAAQ,CAACM,OAAO,CAAEC,GAAG,IAAK;MAC3BA,GAAG,CAACE,IAAI,CAACC,EAAE,EAAE,GAAGC,IAAI,CAAC;IACzB,CAAC,CAAC;IACF,OAAO,IAAI;EACf;EACAC,WAAW,CAACC,IAAI,EAAE;IACd,MAAMC,SAAS,GAAG,IAAIpB,WAAW,CAACE,SAAS,CAAC,IAAI,CAACE,MAAM,EAAEe,IAAI,CAAC;IAC9DC,SAAS,CAACC,IAAI,GAAG,IAAI,CAACA,IAAI,CAACC,KAAK,CAAC,CAAC,CAAC;IACnC,IAAI,CAACC,SAAS,CAAC,SAAS,CAAC,CAACX,OAAO,CAAEY,QAAQ,IAAKJ,SAAS,CAACK,EAAE,CAAC,SAAS,EAAED,QAAQ,CAAC,CAAC;IAClF,IAAI,CAACD,SAAS,CAAC,YAAY,CAAC,CAACX,OAAO,CAAEY,QAAQ,IAAKJ,SAAS,CAACK,EAAE,CAAC,YAAY,EAAED,QAAQ,CAAC,CAAC;IACxF,IAAI,CAAClB,QAAQ,CAACoB,GAAG,CAACN,SAAS,CAAC;IAC5B,IAAI,CAAChB,MAAM,CAACuB,KAAK,CAACC,GAAG,CAACT,IAAI,EAAEC,SAAS,CAAC;IACtC,OAAOA,SAAS;EACpB;EACAS,YAAY,GAAG;IACX;IACA;IACA;IACA;IACA;IACA,MAAM,IAAIC,KAAK,CAAC,sDAAsD,CAAC;EAC3E;AACJ;AACAjC,OAAO,CAACE,eAAe,GAAGA,eAAe;AACzCA,eAAe,CAACM,KAAK,GAAG,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}