{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Socket = exports.RESERVED_EVENTS = void 0;\nconst socket_io_parser_1 = require(\"socket.io-parser\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst typed_events_1 = require(\"./typed-events\");\nconst base64id_1 = __importDefault(require(\"base64id\"));\nconst broadcast_operator_1 = require(\"./broadcast-operator\");\nconst debug = (0, debug_1.default)(\"socket.io:socket\");\nexports.RESERVED_EVENTS = new Set([\"connect\", \"connect_error\", \"disconnect\", \"disconnecting\", \"newListener\", \"removeListener\"]);\nfunction noop() {}\n/**\n * This is the main object for interacting with a client.\n *\n * A Socket belongs to a given {@link Namespace} and uses an underlying {@link Client} to communicate.\n *\n * Within each {@link Namespace}, you can also define arbitrary channels (called \"rooms\") that the {@link Socket} can\n * join and leave. That provides a convenient way to broadcast to a group of socket instances.\n *\n * @example\n * io.on(\"connection\", (socket) => {\n *   console.log(`socket ${socket.id} connected`);\n *\n *   // send an event to the client\n *   socket.emit(\"foo\", \"bar\");\n *\n *   socket.on(\"foobar\", () => {\n *     // an event was received from the client\n *   });\n *\n *   // join the room named \"room1\"\n *   socket.join(\"room1\");\n *\n *   // broadcast to everyone in the room named \"room1\"\n *   io.to(\"room1\").emit(\"hello\");\n *\n *   // upon disconnection\n *   socket.on(\"disconnect\", (reason) => {\n *     console.log(`socket ${socket.id} disconnected due to ${reason}`);\n *   });\n * });\n */\nclass Socket extends typed_events_1.StrictEventEmitter {\n  /**\n   * Interface to a `Client` for a given `Namespace`.\n   *\n   * @param {Namespace} nsp\n   * @param {Client} client\n   * @param {Object} auth\n   * @package\n   */\n  constructor(nsp, client, auth) {\n    super();\n    this.nsp = nsp;\n    this.client = client;\n    /**\n     * Additional information that can be attached to the Socket instance and which will be used in the\n     * {@link Server.fetchSockets()} method.\n     */\n    this.data = {};\n    /**\n     * Whether the socket is currently connected or not.\n     *\n     * @example\n     * io.use((socket, next) => {\n     *   console.log(socket.connected); // false\n     *   next();\n     * });\n     *\n     * io.on(\"connection\", (socket) => {\n     *   console.log(socket.connected); // true\n     * });\n     */\n    this.connected = false;\n    this.acks = new Map();\n    this.fns = [];\n    this.flags = {};\n    this.server = nsp.server;\n    this.adapter = this.nsp.adapter;\n    if (client.conn.protocol === 3) {\n      // @ts-ignore\n      this.id = nsp.name !== \"/\" ? nsp.name + \"#\" + client.id : client.id;\n    } else {\n      this.id = base64id_1.default.generateId(); // don't reuse the Engine.IO id because it's sensitive information\n    }\n\n    this.handshake = this.buildHandshake(auth);\n  }\n  /**\n   * Builds the `handshake` BC object\n   *\n   * @private\n   */\n  buildHandshake(auth) {\n    return {\n      headers: this.request.headers,\n      time: new Date() + \"\",\n      address: this.conn.remoteAddress,\n      xdomain: !!this.request.headers.origin,\n      // @ts-ignore\n      secure: !!this.request.connection.encrypted,\n      issued: +new Date(),\n      url: this.request.url,\n      // @ts-ignore\n      query: this.request._query,\n      auth\n    };\n  }\n  /**\n   * Emits to this client.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   socket.emit(\"hello\", \"world\");\n   *\n   *   // all serializable datastructures are supported (no need to call JSON.stringify)\n   *   socket.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Buffer.from([6]) });\n   *\n   *   // with an acknowledgement from the client\n   *   socket.emit(\"hello\", \"world\", (val) => {\n   *     // ...\n   *   });\n   * });\n   *\n   * @return Always returns `true`.\n   */\n  emit(ev) {\n    if (exports.RESERVED_EVENTS.has(ev)) {\n      throw new Error(`\"${String(ev)}\" is a reserved event name`);\n    }\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    const data = [ev, ...args];\n    const packet = {\n      type: socket_io_parser_1.PacketType.EVENT,\n      data: data\n    };\n    // access last argument to see if it's an ACK callback\n    if (typeof data[data.length - 1] === \"function\") {\n      const id = this.nsp._ids++;\n      debug(\"emitting packet with ack id %d\", id);\n      this.registerAckCallback(id, data.pop());\n      packet.id = id;\n    }\n    const flags = Object.assign({}, this.flags);\n    this.flags = {};\n    this.notifyOutgoingListeners(packet);\n    this.packet(packet, flags);\n    return true;\n  }\n  /**\n   * @private\n   */\n  registerAckCallback(id, ack) {\n    var _this = this;\n    const timeout = this.flags.timeout;\n    if (timeout === undefined) {\n      this.acks.set(id, ack);\n      return;\n    }\n    const timer = setTimeout(() => {\n      debug(\"event with ack id %d has timed out after %d ms\", id, timeout);\n      this.acks.delete(id);\n      ack.call(this, new Error(\"operation has timed out\"));\n    }, timeout);\n    this.acks.set(id, function () {\n      clearTimeout(timer);\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      ack.apply(_this, [null, ...args]);\n    });\n  }\n  /**\n   * Targets a room when broadcasting.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   // the “foo” event will be broadcast to all connected clients in the “room-101” room, except this socket\n   *   socket.to(\"room-101\").emit(\"foo\", \"bar\");\n   *\n   *   // the code above is equivalent to:\n   *   io.to(\"room-101\").except(socket.id).emit(\"foo\", \"bar\");\n   *\n   *   // with an array of rooms (a client will be notified at most once)\n   *   socket.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n   *\n   *   // with multiple chained calls\n   *   socket.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n   * });\n   *\n   * @param room - a room, or an array of rooms\n   * @return a new {@link BroadcastOperator} instance for chaining\n   */\n  to(room) {\n    return this.newBroadcastOperator().to(room);\n  }\n  /**\n   * Targets a room when broadcasting. Similar to `to()`, but might feel clearer in some cases:\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   // disconnect all clients in the \"room-101\" room, except this socket\n   *   socket.in(\"room-101\").disconnectSockets();\n   * });\n   *\n   * @param room - a room, or an array of rooms\n   * @return a new {@link BroadcastOperator} instance for chaining\n   */\n  in(room) {\n    return this.newBroadcastOperator().in(room);\n  }\n  /**\n   * Excludes a room when broadcasting.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n   *   // and this socket\n   *   socket.except(\"room-101\").emit(\"foo\", \"bar\");\n   *\n   *   // with an array of rooms\n   *   socket.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n   *\n   *   // with multiple chained calls\n   *   socket.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n   * });\n   *\n   * @param room - a room, or an array of rooms\n   * @return a new {@link BroadcastOperator} instance for chaining\n   */\n  except(room) {\n    return this.newBroadcastOperator().except(room);\n  }\n  /**\n   * Sends a `message` event.\n   *\n   * This method mimics the WebSocket.send() method.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   socket.send(\"hello\");\n   *\n   *   // this is equivalent to\n   *   socket.emit(\"message\", \"hello\");\n   * });\n   *\n   * @return self\n   */\n  send() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    this.emit(\"message\", ...args);\n    return this;\n  }\n  /**\n   * Sends a `message` event. Alias of {@link send}.\n   *\n   * @return self\n   */\n  write() {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    this.emit(\"message\", ...args);\n    return this;\n  }\n  /**\n   * Writes a packet.\n   *\n   * @param {Object} packet - packet object\n   * @param {Object} opts - options\n   * @private\n   */\n  packet(packet) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    packet.nsp = this.nsp.name;\n    opts.compress = false !== opts.compress;\n    this.client._packet(packet, opts);\n  }\n  /**\n   * Joins a room.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   // join a single room\n   *   socket.join(\"room1\");\n   *\n   *   // join multiple rooms\n   *   socket.join([\"room1\", \"room2\"]);\n   * });\n   *\n   * @param {String|Array} rooms - room or array of rooms\n   * @return a Promise or nothing, depending on the adapter\n   */\n  join(rooms) {\n    debug(\"join room %s\", rooms);\n    return this.adapter.addAll(this.id, new Set(Array.isArray(rooms) ? rooms : [rooms]));\n  }\n  /**\n   * Leaves a room.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   // leave a single room\n   *   socket.leave(\"room1\");\n   *\n   *   // leave multiple rooms\n   *   socket.leave(\"room1\").leave(\"room2\");\n   * });\n   *\n   * @param {String} room\n   * @return a Promise or nothing, depending on the adapter\n   */\n  leave(room) {\n    debug(\"leave room %s\", room);\n    return this.adapter.del(this.id, room);\n  }\n  /**\n   * Leave all rooms.\n   *\n   * @private\n   */\n  leaveAll() {\n    this.adapter.delAll(this.id);\n  }\n  /**\n   * Called by `Namespace` upon successful\n   * middleware execution (ie: authorization).\n   * Socket is added to namespace array before\n   * call to join, so adapters can access it.\n   *\n   * @private\n   */\n  _onconnect() {\n    debug(\"socket connected - writing packet\");\n    this.connected = true;\n    this.join(this.id);\n    if (this.conn.protocol === 3) {\n      this.packet({\n        type: socket_io_parser_1.PacketType.CONNECT\n      });\n    } else {\n      this.packet({\n        type: socket_io_parser_1.PacketType.CONNECT,\n        data: {\n          sid: this.id\n        }\n      });\n    }\n  }\n  /**\n   * Called with each packet. Called by `Client`.\n   *\n   * @param {Object} packet\n   * @private\n   */\n  _onpacket(packet) {\n    debug(\"got packet %j\", packet);\n    switch (packet.type) {\n      case socket_io_parser_1.PacketType.EVENT:\n        this.onevent(packet);\n        break;\n      case socket_io_parser_1.PacketType.BINARY_EVENT:\n        this.onevent(packet);\n        break;\n      case socket_io_parser_1.PacketType.ACK:\n        this.onack(packet);\n        break;\n      case socket_io_parser_1.PacketType.BINARY_ACK:\n        this.onack(packet);\n        break;\n      case socket_io_parser_1.PacketType.DISCONNECT:\n        this.ondisconnect();\n        break;\n    }\n  }\n  /**\n   * Called upon event packet.\n   *\n   * @param {Packet} packet - packet object\n   * @private\n   */\n  onevent(packet) {\n    const args = packet.data || [];\n    debug(\"emitting event %j\", args);\n    if (null != packet.id) {\n      debug(\"attaching ack callback to event\");\n      args.push(this.ack(packet.id));\n    }\n    if (this._anyListeners && this._anyListeners.length) {\n      const listeners = this._anyListeners.slice();\n      for (const listener of listeners) {\n        listener.apply(this, args);\n      }\n    }\n    this.dispatch(args);\n  }\n  /**\n   * Produces an ack callback to emit with an event.\n   *\n   * @param {Number} id - packet id\n   * @private\n   */\n  ack(id) {\n    const self = this;\n    let sent = false;\n    return function () {\n      // prevent double callbacks\n      if (sent) return;\n      const args = Array.prototype.slice.call(arguments);\n      debug(\"sending ack %j\", args);\n      self.packet({\n        id: id,\n        type: socket_io_parser_1.PacketType.ACK,\n        data: args\n      });\n      sent = true;\n    };\n  }\n  /**\n   * Called upon ack packet.\n   *\n   * @private\n   */\n  onack(packet) {\n    const ack = this.acks.get(packet.id);\n    if (\"function\" == typeof ack) {\n      debug(\"calling ack %s with %j\", packet.id, packet.data);\n      ack.apply(this, packet.data);\n      this.acks.delete(packet.id);\n    } else {\n      debug(\"bad ack %s\", packet.id);\n    }\n  }\n  /**\n   * Called upon client disconnect packet.\n   *\n   * @private\n   */\n  ondisconnect() {\n    debug(\"got disconnect packet\");\n    this._onclose(\"client namespace disconnect\");\n  }\n  /**\n   * Handles a client error.\n   *\n   * @private\n   */\n  _onerror(err) {\n    if (this.listeners(\"error\").length) {\n      this.emitReserved(\"error\", err);\n    } else {\n      console.error(\"Missing error handler on `socket`.\");\n      console.error(err.stack);\n    }\n  }\n  /**\n   * Called upon closing. Called by `Client`.\n   *\n   * @param {String} reason\n   * @throw {Error} optional error object\n   *\n   * @private\n   */\n  _onclose(reason) {\n    if (!this.connected) return this;\n    debug(\"closing socket - reason %s\", reason);\n    this.emitReserved(\"disconnecting\", reason);\n    this._cleanup();\n    this.nsp._remove(this);\n    this.client._remove(this);\n    this.connected = false;\n    this.emitReserved(\"disconnect\", reason);\n    return;\n  }\n  /**\n   * Makes the socket leave all the rooms it was part of and prevents it from joining any other room\n   *\n   * @private\n   */\n  _cleanup() {\n    this.leaveAll();\n    this.join = noop;\n  }\n  /**\n   * Produces an `error` packet.\n   *\n   * @param {Object} err - error object\n   *\n   * @private\n   */\n  _error(err) {\n    this.packet({\n      type: socket_io_parser_1.PacketType.CONNECT_ERROR,\n      data: err\n    });\n  }\n  /**\n   * Disconnects this client.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   // disconnect this socket (the connection might be kept alive for other namespaces)\n   *   socket.disconnect();\n   *\n   *   // disconnect this socket and close the underlying connection\n   *   socket.disconnect(true);\n   * })\n   *\n   * @param {Boolean} close - if `true`, closes the underlying connection\n   * @return self\n   */\n  disconnect() {\n    let close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (!this.connected) return this;\n    if (close) {\n      this.client._disconnect();\n    } else {\n      this.packet({\n        type: socket_io_parser_1.PacketType.DISCONNECT\n      });\n      this._onclose(\"server namespace disconnect\");\n    }\n    return this;\n  }\n  /**\n   * Sets the compress flag.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   socket.compress(false).emit(\"hello\");\n   * });\n   *\n   * @param {Boolean} compress - if `true`, compresses the sending data\n   * @return {Socket} self\n   */\n  compress(compress) {\n    this.flags.compress = compress;\n    return this;\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n   * receive messages (because of network slowness or other issues, or because they’re connected through long polling\n   * and is in the middle of a request-response cycle).\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   socket.volatile.emit(\"hello\"); // the client may or may not receive it\n   * });\n   *\n   * @return {Socket} self\n   */\n  get volatile() {\n    this.flags.volatile = true;\n    return this;\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the event data will only be broadcast to every sockets but the\n   * sender.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   // the “foo” event will be broadcast to all connected clients, except this socket\n   *   socket.broadcast.emit(\"foo\", \"bar\");\n   * });\n   *\n   * @return a new {@link BroadcastOperator} instance for chaining\n   */\n  get broadcast() {\n    return this.newBroadcastOperator();\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   // the “foo” event will be broadcast to all connected clients on this node, except this socket\n   *   socket.local.emit(\"foo\", \"bar\");\n   * });\n   *\n   * @return a new {@link BroadcastOperator} instance for chaining\n   */\n  get local() {\n    return this.newBroadcastOperator().local;\n  }\n  /**\n   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n   * given number of milliseconds have elapsed without an acknowledgement from the client:\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   socket.timeout(5000).emit(\"my-event\", (err) => {\n   *     if (err) {\n   *       // the client did not acknowledge the event in the given delay\n   *     }\n   *   });\n   * });\n   *\n   * @returns self\n   */\n  timeout(timeout) {\n    this.flags.timeout = timeout;\n    return this;\n  }\n  /**\n   * Dispatch incoming event to socket listeners.\n   *\n   * @param {Array} event - event that will get emitted\n   * @private\n   */\n  dispatch(event) {\n    debug(\"dispatching an event %j\", event);\n    this.run(event, err => {\n      process.nextTick(() => {\n        if (err) {\n          return this._onerror(err);\n        }\n        if (this.connected) {\n          super.emitUntyped.apply(this, event);\n        } else {\n          debug(\"ignore packet received after disconnection\");\n        }\n      });\n    });\n  }\n  /**\n   * Sets up socket middleware.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   socket.use(([event, ...args], next) => {\n   *     if (isUnauthorized(event)) {\n   *       return next(new Error(\"unauthorized event\"));\n   *     }\n   *     // do not forget to call next\n   *     next();\n   *   });\n   *\n   *   socket.on(\"error\", (err) => {\n   *     if (err && err.message === \"unauthorized event\") {\n   *       socket.disconnect();\n   *     }\n   *   });\n   * });\n   *\n   * @param {Function} fn - middleware function (event, next)\n   * @return {Socket} self\n   */\n  use(fn) {\n    this.fns.push(fn);\n    return this;\n  }\n  /**\n   * Executes the middleware for an incoming event.\n   *\n   * @param {Array} event - event that will get emitted\n   * @param {Function} fn - last fn call in the middleware\n   * @private\n   */\n  run(event, fn) {\n    const fns = this.fns.slice(0);\n    if (!fns.length) return fn(null);\n    function run(i) {\n      fns[i](event, function (err) {\n        // upon error, short-circuit\n        if (err) return fn(err);\n        // if no middleware left, summon callback\n        if (!fns[i + 1]) return fn(null);\n        // go on to next\n        run(i + 1);\n      });\n    }\n    run(0);\n  }\n  /**\n   * Whether the socket is currently disconnected\n   */\n  get disconnected() {\n    return !this.connected;\n  }\n  /**\n   * A reference to the request that originated the underlying Engine.IO Socket.\n   */\n  get request() {\n    return this.client.request;\n  }\n  /**\n   * A reference to the underlying Client transport connection (Engine.IO Socket object).\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   console.log(socket.conn.transport.name); // prints \"polling\" or \"websocket\"\n   *\n   *   socket.conn.once(\"upgrade\", () => {\n   *     console.log(socket.conn.transport.name); // prints \"websocket\"\n   *   });\n   * });\n   */\n  get conn() {\n    return this.client.conn;\n  }\n  /**\n   * Returns the rooms the socket is currently in.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   console.log(socket.rooms); // Set { <socket.id> }\n   *\n   *   socket.join(\"room1\");\n   *\n   *   console.log(socket.rooms); // Set { <socket.id>, \"room1\" }\n   * });\n   */\n  get rooms() {\n    return this.adapter.socketRooms(this.id) || new Set();\n  }\n  /**\n   * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to\n   * the callback.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   socket.onAny((event, ...args) => {\n   *     console.log(`got event ${event}`);\n   *   });\n   * });\n   *\n   * @param listener\n   */\n  onAny(listener) {\n    this._anyListeners = this._anyListeners || [];\n    this._anyListeners.push(listener);\n    return this;\n  }\n  /**\n   * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to\n   * the callback. The listener is added to the beginning of the listeners array.\n   *\n   * @param listener\n   */\n  prependAny(listener) {\n    this._anyListeners = this._anyListeners || [];\n    this._anyListeners.unshift(listener);\n    return this;\n  }\n  /**\n   * Removes the listener that will be fired when any event is received.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   const catchAllListener = (event, ...args) => {\n   *     console.log(`got event ${event}`);\n   *   }\n   *\n   *   socket.onAny(catchAllListener);\n   *\n   *   // remove a specific listener\n   *   socket.offAny(catchAllListener);\n   *\n   *   // or remove all listeners\n   *   socket.offAny();\n   * });\n   *\n   * @param listener\n   */\n  offAny(listener) {\n    if (!this._anyListeners) {\n      return this;\n    }\n    if (listener) {\n      const listeners = this._anyListeners;\n      for (let i = 0; i < listeners.length; i++) {\n        if (listener === listeners[i]) {\n          listeners.splice(i, 1);\n          return this;\n        }\n      }\n    } else {\n      this._anyListeners = [];\n    }\n    return this;\n  }\n  /**\n   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n   * e.g. to remove listeners.\n   */\n  listenersAny() {\n    return this._anyListeners || [];\n  }\n  /**\n   * Adds a listener that will be fired when any event is sent. The event name is passed as the first argument to\n   * the callback.\n   *\n   * Note: acknowledgements sent to the client are not included.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   socket.onAnyOutgoing((event, ...args) => {\n   *     console.log(`sent event ${event}`);\n   *   });\n   * });\n   *\n   * @param listener\n   */\n  onAnyOutgoing(listener) {\n    this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n    this._anyOutgoingListeners.push(listener);\n    return this;\n  }\n  /**\n   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n   * callback. The listener is added to the beginning of the listeners array.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   socket.prependAnyOutgoing((event, ...args) => {\n   *     console.log(`sent event ${event}`);\n   *   });\n   * });\n   *\n   * @param listener\n   */\n  prependAnyOutgoing(listener) {\n    this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n    this._anyOutgoingListeners.unshift(listener);\n    return this;\n  }\n  /**\n   * Removes the listener that will be fired when any event is sent.\n   *\n   * @example\n   * io.on(\"connection\", (socket) => {\n   *   const catchAllListener = (event, ...args) => {\n   *     console.log(`sent event ${event}`);\n   *   }\n   *\n   *   socket.onAnyOutgoing(catchAllListener);\n   *\n   *   // remove a specific listener\n   *   socket.offAnyOutgoing(catchAllListener);\n   *\n   *   // or remove all listeners\n   *   socket.offAnyOutgoing();\n   * });\n   *\n   * @param listener - the catch-all listener\n   */\n  offAnyOutgoing(listener) {\n    if (!this._anyOutgoingListeners) {\n      return this;\n    }\n    if (listener) {\n      const listeners = this._anyOutgoingListeners;\n      for (let i = 0; i < listeners.length; i++) {\n        if (listener === listeners[i]) {\n          listeners.splice(i, 1);\n          return this;\n        }\n      }\n    } else {\n      this._anyOutgoingListeners = [];\n    }\n    return this;\n  }\n  /**\n   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n   * e.g. to remove listeners.\n   */\n  listenersAnyOutgoing() {\n    return this._anyOutgoingListeners || [];\n  }\n  /**\n   * Notify the listeners for each packet sent (emit or broadcast)\n   *\n   * @param packet\n   *\n   * @private\n   */\n  notifyOutgoingListeners(packet) {\n    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n      const listeners = this._anyOutgoingListeners.slice();\n      for (const listener of listeners) {\n        listener.apply(this, packet.data);\n      }\n    }\n  }\n  newBroadcastOperator() {\n    const flags = Object.assign({}, this.flags);\n    this.flags = {};\n    return new broadcast_operator_1.BroadcastOperator(this.adapter, new Set(), new Set([this.id]), flags);\n  }\n}\nexports.Socket = Socket;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","Socket","RESERVED_EVENTS","socket_io_parser_1","require","debug_1","typed_events_1","base64id_1","broadcast_operator_1","debug","default","Set","noop","StrictEventEmitter","constructor","nsp","client","auth","data","connected","acks","Map","fns","flags","server","adapter","conn","protocol","id","name","generateId","handshake","buildHandshake","headers","request","time","Date","address","remoteAddress","xdomain","origin","secure","connection","encrypted","issued","url","query","_query","emit","ev","has","Error","String","args","packet","type","PacketType","EVENT","length","_ids","registerAckCallback","pop","assign","notifyOutgoingListeners","ack","timeout","undefined","set","timer","setTimeout","delete","call","clearTimeout","apply","to","room","newBroadcastOperator","in","except","send","write","opts","compress","_packet","join","rooms","addAll","Array","isArray","leave","del","leaveAll","delAll","_onconnect","CONNECT","sid","_onpacket","onevent","BINARY_EVENT","ACK","onack","BINARY_ACK","DISCONNECT","ondisconnect","push","_anyListeners","listeners","slice","listener","dispatch","self","sent","prototype","arguments","get","_onclose","_onerror","err","emitReserved","console","error","stack","reason","_cleanup","_remove","_error","CONNECT_ERROR","disconnect","close","_disconnect","volatile","broadcast","local","event","run","process","nextTick","emitUntyped","use","fn","i","disconnected","socketRooms","onAny","prependAny","unshift","offAny","splice","listenersAny","onAnyOutgoing","_anyOutgoingListeners","prependAnyOutgoing","offAnyOutgoing","listenersAnyOutgoing","BroadcastOperator"],"sources":["/home/samuel/Documents/chatApp/node_modules/socket.io/dist/socket.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Socket = exports.RESERVED_EVENTS = void 0;\nconst socket_io_parser_1 = require(\"socket.io-parser\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst typed_events_1 = require(\"./typed-events\");\nconst base64id_1 = __importDefault(require(\"base64id\"));\nconst broadcast_operator_1 = require(\"./broadcast-operator\");\nconst debug = (0, debug_1.default)(\"socket.io:socket\");\nexports.RESERVED_EVENTS = new Set([\n    \"connect\",\n    \"connect_error\",\n    \"disconnect\",\n    \"disconnecting\",\n    \"newListener\",\n    \"removeListener\",\n]);\nfunction noop() { }\n/**\n * This is the main object for interacting with a client.\n *\n * A Socket belongs to a given {@link Namespace} and uses an underlying {@link Client} to communicate.\n *\n * Within each {@link Namespace}, you can also define arbitrary channels (called \"rooms\") that the {@link Socket} can\n * join and leave. That provides a convenient way to broadcast to a group of socket instances.\n *\n * @example\n * io.on(\"connection\", (socket) => {\n *   console.log(`socket ${socket.id} connected`);\n *\n *   // send an event to the client\n *   socket.emit(\"foo\", \"bar\");\n *\n *   socket.on(\"foobar\", () => {\n *     // an event was received from the client\n *   });\n *\n *   // join the room named \"room1\"\n *   socket.join(\"room1\");\n *\n *   // broadcast to everyone in the room named \"room1\"\n *   io.to(\"room1\").emit(\"hello\");\n *\n *   // upon disconnection\n *   socket.on(\"disconnect\", (reason) => {\n *     console.log(`socket ${socket.id} disconnected due to ${reason}`);\n *   });\n * });\n */\nclass Socket extends typed_events_1.StrictEventEmitter {\n    /**\n     * Interface to a `Client` for a given `Namespace`.\n     *\n     * @param {Namespace} nsp\n     * @param {Client} client\n     * @param {Object} auth\n     * @package\n     */\n    constructor(nsp, client, auth) {\n        super();\n        this.nsp = nsp;\n        this.client = client;\n        /**\n         * Additional information that can be attached to the Socket instance and which will be used in the\n         * {@link Server.fetchSockets()} method.\n         */\n        this.data = {};\n        /**\n         * Whether the socket is currently connected or not.\n         *\n         * @example\n         * io.use((socket, next) => {\n         *   console.log(socket.connected); // false\n         *   next();\n         * });\n         *\n         * io.on(\"connection\", (socket) => {\n         *   console.log(socket.connected); // true\n         * });\n         */\n        this.connected = false;\n        this.acks = new Map();\n        this.fns = [];\n        this.flags = {};\n        this.server = nsp.server;\n        this.adapter = this.nsp.adapter;\n        if (client.conn.protocol === 3) {\n            // @ts-ignore\n            this.id = nsp.name !== \"/\" ? nsp.name + \"#\" + client.id : client.id;\n        }\n        else {\n            this.id = base64id_1.default.generateId(); // don't reuse the Engine.IO id because it's sensitive information\n        }\n        this.handshake = this.buildHandshake(auth);\n    }\n    /**\n     * Builds the `handshake` BC object\n     *\n     * @private\n     */\n    buildHandshake(auth) {\n        return {\n            headers: this.request.headers,\n            time: new Date() + \"\",\n            address: this.conn.remoteAddress,\n            xdomain: !!this.request.headers.origin,\n            // @ts-ignore\n            secure: !!this.request.connection.encrypted,\n            issued: +new Date(),\n            url: this.request.url,\n            // @ts-ignore\n            query: this.request._query,\n            auth,\n        };\n    }\n    /**\n     * Emits to this client.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.emit(\"hello\", \"world\");\n     *\n     *   // all serializable datastructures are supported (no need to call JSON.stringify)\n     *   socket.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Buffer.from([6]) });\n     *\n     *   // with an acknowledgement from the client\n     *   socket.emit(\"hello\", \"world\", (val) => {\n     *     // ...\n     *   });\n     * });\n     *\n     * @return Always returns `true`.\n     */\n    emit(ev, ...args) {\n        if (exports.RESERVED_EVENTS.has(ev)) {\n            throw new Error(`\"${String(ev)}\" is a reserved event name`);\n        }\n        const data = [ev, ...args];\n        const packet = {\n            type: socket_io_parser_1.PacketType.EVENT,\n            data: data,\n        };\n        // access last argument to see if it's an ACK callback\n        if (typeof data[data.length - 1] === \"function\") {\n            const id = this.nsp._ids++;\n            debug(\"emitting packet with ack id %d\", id);\n            this.registerAckCallback(id, data.pop());\n            packet.id = id;\n        }\n        const flags = Object.assign({}, this.flags);\n        this.flags = {};\n        this.notifyOutgoingListeners(packet);\n        this.packet(packet, flags);\n        return true;\n    }\n    /**\n     * @private\n     */\n    registerAckCallback(id, ack) {\n        const timeout = this.flags.timeout;\n        if (timeout === undefined) {\n            this.acks.set(id, ack);\n            return;\n        }\n        const timer = setTimeout(() => {\n            debug(\"event with ack id %d has timed out after %d ms\", id, timeout);\n            this.acks.delete(id);\n            ack.call(this, new Error(\"operation has timed out\"));\n        }, timeout);\n        this.acks.set(id, (...args) => {\n            clearTimeout(timer);\n            ack.apply(this, [null, ...args]);\n        });\n    }\n    /**\n     * Targets a room when broadcasting.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the “foo” event will be broadcast to all connected clients in the “room-101” room, except this socket\n     *   socket.to(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     *   // the code above is equivalent to:\n     *   io.to(\"room-101\").except(socket.id).emit(\"foo\", \"bar\");\n     *\n     *   // with an array of rooms (a client will be notified at most once)\n     *   socket.to([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     *   // with multiple chained calls\n     *   socket.to(\"room-101\").to(\"room-102\").emit(\"foo\", \"bar\");\n     * });\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    to(room) {\n        return this.newBroadcastOperator().to(room);\n    }\n    /**\n     * Targets a room when broadcasting. Similar to `to()`, but might feel clearer in some cases:\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // disconnect all clients in the \"room-101\" room, except this socket\n     *   socket.in(\"room-101\").disconnectSockets();\n     * });\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    in(room) {\n        return this.newBroadcastOperator().in(room);\n    }\n    /**\n     * Excludes a room when broadcasting.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the \"foo\" event will be broadcast to all connected clients, except the ones that are in the \"room-101\" room\n     *   // and this socket\n     *   socket.except(\"room-101\").emit(\"foo\", \"bar\");\n     *\n     *   // with an array of rooms\n     *   socket.except([\"room-101\", \"room-102\"]).emit(\"foo\", \"bar\");\n     *\n     *   // with multiple chained calls\n     *   socket.except(\"room-101\").except(\"room-102\").emit(\"foo\", \"bar\");\n     * });\n     *\n     * @param room - a room, or an array of rooms\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    except(room) {\n        return this.newBroadcastOperator().except(room);\n    }\n    /**\n     * Sends a `message` event.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.send(\"hello\");\n     *\n     *   // this is equivalent to\n     *   socket.emit(\"message\", \"hello\");\n     * });\n     *\n     * @return self\n     */\n    send(...args) {\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Sends a `message` event. Alias of {@link send}.\n     *\n     * @return self\n     */\n    write(...args) {\n        this.emit(\"message\", ...args);\n        return this;\n    }\n    /**\n     * Writes a packet.\n     *\n     * @param {Object} packet - packet object\n     * @param {Object} opts - options\n     * @private\n     */\n    packet(packet, opts = {}) {\n        packet.nsp = this.nsp.name;\n        opts.compress = false !== opts.compress;\n        this.client._packet(packet, opts);\n    }\n    /**\n     * Joins a room.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // join a single room\n     *   socket.join(\"room1\");\n     *\n     *   // join multiple rooms\n     *   socket.join([\"room1\", \"room2\"]);\n     * });\n     *\n     * @param {String|Array} rooms - room or array of rooms\n     * @return a Promise or nothing, depending on the adapter\n     */\n    join(rooms) {\n        debug(\"join room %s\", rooms);\n        return this.adapter.addAll(this.id, new Set(Array.isArray(rooms) ? rooms : [rooms]));\n    }\n    /**\n     * Leaves a room.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // leave a single room\n     *   socket.leave(\"room1\");\n     *\n     *   // leave multiple rooms\n     *   socket.leave(\"room1\").leave(\"room2\");\n     * });\n     *\n     * @param {String} room\n     * @return a Promise or nothing, depending on the adapter\n     */\n    leave(room) {\n        debug(\"leave room %s\", room);\n        return this.adapter.del(this.id, room);\n    }\n    /**\n     * Leave all rooms.\n     *\n     * @private\n     */\n    leaveAll() {\n        this.adapter.delAll(this.id);\n    }\n    /**\n     * Called by `Namespace` upon successful\n     * middleware execution (ie: authorization).\n     * Socket is added to namespace array before\n     * call to join, so adapters can access it.\n     *\n     * @private\n     */\n    _onconnect() {\n        debug(\"socket connected - writing packet\");\n        this.connected = true;\n        this.join(this.id);\n        if (this.conn.protocol === 3) {\n            this.packet({ type: socket_io_parser_1.PacketType.CONNECT });\n        }\n        else {\n            this.packet({ type: socket_io_parser_1.PacketType.CONNECT, data: { sid: this.id } });\n        }\n    }\n    /**\n     * Called with each packet. Called by `Client`.\n     *\n     * @param {Object} packet\n     * @private\n     */\n    _onpacket(packet) {\n        debug(\"got packet %j\", packet);\n        switch (packet.type) {\n            case socket_io_parser_1.PacketType.EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser_1.PacketType.BINARY_EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser_1.PacketType.ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser_1.PacketType.BINARY_ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser_1.PacketType.DISCONNECT:\n                this.ondisconnect();\n                break;\n        }\n    }\n    /**\n     * Called upon event packet.\n     *\n     * @param {Packet} packet - packet object\n     * @private\n     */\n    onevent(packet) {\n        const args = packet.data || [];\n        debug(\"emitting event %j\", args);\n        if (null != packet.id) {\n            debug(\"attaching ack callback to event\");\n            args.push(this.ack(packet.id));\n        }\n        if (this._anyListeners && this._anyListeners.length) {\n            const listeners = this._anyListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, args);\n            }\n        }\n        this.dispatch(args);\n    }\n    /**\n     * Produces an ack callback to emit with an event.\n     *\n     * @param {Number} id - packet id\n     * @private\n     */\n    ack(id) {\n        const self = this;\n        let sent = false;\n        return function () {\n            // prevent double callbacks\n            if (sent)\n                return;\n            const args = Array.prototype.slice.call(arguments);\n            debug(\"sending ack %j\", args);\n            self.packet({\n                id: id,\n                type: socket_io_parser_1.PacketType.ACK,\n                data: args,\n            });\n            sent = true;\n        };\n    }\n    /**\n     * Called upon ack packet.\n     *\n     * @private\n     */\n    onack(packet) {\n        const ack = this.acks.get(packet.id);\n        if (\"function\" == typeof ack) {\n            debug(\"calling ack %s with %j\", packet.id, packet.data);\n            ack.apply(this, packet.data);\n            this.acks.delete(packet.id);\n        }\n        else {\n            debug(\"bad ack %s\", packet.id);\n        }\n    }\n    /**\n     * Called upon client disconnect packet.\n     *\n     * @private\n     */\n    ondisconnect() {\n        debug(\"got disconnect packet\");\n        this._onclose(\"client namespace disconnect\");\n    }\n    /**\n     * Handles a client error.\n     *\n     * @private\n     */\n    _onerror(err) {\n        if (this.listeners(\"error\").length) {\n            this.emitReserved(\"error\", err);\n        }\n        else {\n            console.error(\"Missing error handler on `socket`.\");\n            console.error(err.stack);\n        }\n    }\n    /**\n     * Called upon closing. Called by `Client`.\n     *\n     * @param {String} reason\n     * @throw {Error} optional error object\n     *\n     * @private\n     */\n    _onclose(reason) {\n        if (!this.connected)\n            return this;\n        debug(\"closing socket - reason %s\", reason);\n        this.emitReserved(\"disconnecting\", reason);\n        this._cleanup();\n        this.nsp._remove(this);\n        this.client._remove(this);\n        this.connected = false;\n        this.emitReserved(\"disconnect\", reason);\n        return;\n    }\n    /**\n     * Makes the socket leave all the rooms it was part of and prevents it from joining any other room\n     *\n     * @private\n     */\n    _cleanup() {\n        this.leaveAll();\n        this.join = noop;\n    }\n    /**\n     * Produces an `error` packet.\n     *\n     * @param {Object} err - error object\n     *\n     * @private\n     */\n    _error(err) {\n        this.packet({ type: socket_io_parser_1.PacketType.CONNECT_ERROR, data: err });\n    }\n    /**\n     * Disconnects this client.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // disconnect this socket (the connection might be kept alive for other namespaces)\n     *   socket.disconnect();\n     *\n     *   // disconnect this socket and close the underlying connection\n     *   socket.disconnect(true);\n     * })\n     *\n     * @param {Boolean} close - if `true`, closes the underlying connection\n     * @return self\n     */\n    disconnect(close = false) {\n        if (!this.connected)\n            return this;\n        if (close) {\n            this.client._disconnect();\n        }\n        else {\n            this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });\n            this._onclose(\"server namespace disconnect\");\n        }\n        return this;\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.compress(false).emit(\"hello\");\n     * });\n     *\n     * @param {Boolean} compress - if `true`, compresses the sending data\n     * @return {Socket} self\n     */\n    compress(compress) {\n        this.flags.compress = compress;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to\n     * receive messages (because of network slowness or other issues, or because they’re connected through long polling\n     * and is in the middle of a request-response cycle).\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.volatile.emit(\"hello\"); // the client may or may not receive it\n     * });\n     *\n     * @return {Socket} self\n     */\n    get volatile() {\n        this.flags.volatile = true;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to every sockets but the\n     * sender.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the “foo” event will be broadcast to all connected clients, except this socket\n     *   socket.broadcast.emit(\"foo\", \"bar\");\n     * });\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    get broadcast() {\n        return this.newBroadcastOperator();\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   // the “foo” event will be broadcast to all connected clients on this node, except this socket\n     *   socket.local.emit(\"foo\", \"bar\");\n     * });\n     *\n     * @return a new {@link BroadcastOperator} instance for chaining\n     */\n    get local() {\n        return this.newBroadcastOperator().local;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n     * given number of milliseconds have elapsed without an acknowledgement from the client:\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.timeout(5000).emit(\"my-event\", (err) => {\n     *     if (err) {\n     *       // the client did not acknowledge the event in the given delay\n     *     }\n     *   });\n     * });\n     *\n     * @returns self\n     */\n    timeout(timeout) {\n        this.flags.timeout = timeout;\n        return this;\n    }\n    /**\n     * Dispatch incoming event to socket listeners.\n     *\n     * @param {Array} event - event that will get emitted\n     * @private\n     */\n    dispatch(event) {\n        debug(\"dispatching an event %j\", event);\n        this.run(event, (err) => {\n            process.nextTick(() => {\n                if (err) {\n                    return this._onerror(err);\n                }\n                if (this.connected) {\n                    super.emitUntyped.apply(this, event);\n                }\n                else {\n                    debug(\"ignore packet received after disconnection\");\n                }\n            });\n        });\n    }\n    /**\n     * Sets up socket middleware.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.use(([event, ...args], next) => {\n     *     if (isUnauthorized(event)) {\n     *       return next(new Error(\"unauthorized event\"));\n     *     }\n     *     // do not forget to call next\n     *     next();\n     *   });\n     *\n     *   socket.on(\"error\", (err) => {\n     *     if (err && err.message === \"unauthorized event\") {\n     *       socket.disconnect();\n     *     }\n     *   });\n     * });\n     *\n     * @param {Function} fn - middleware function (event, next)\n     * @return {Socket} self\n     */\n    use(fn) {\n        this.fns.push(fn);\n        return this;\n    }\n    /**\n     * Executes the middleware for an incoming event.\n     *\n     * @param {Array} event - event that will get emitted\n     * @param {Function} fn - last fn call in the middleware\n     * @private\n     */\n    run(event, fn) {\n        const fns = this.fns.slice(0);\n        if (!fns.length)\n            return fn(null);\n        function run(i) {\n            fns[i](event, function (err) {\n                // upon error, short-circuit\n                if (err)\n                    return fn(err);\n                // if no middleware left, summon callback\n                if (!fns[i + 1])\n                    return fn(null);\n                // go on to next\n                run(i + 1);\n            });\n        }\n        run(0);\n    }\n    /**\n     * Whether the socket is currently disconnected\n     */\n    get disconnected() {\n        return !this.connected;\n    }\n    /**\n     * A reference to the request that originated the underlying Engine.IO Socket.\n     */\n    get request() {\n        return this.client.request;\n    }\n    /**\n     * A reference to the underlying Client transport connection (Engine.IO Socket object).\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   console.log(socket.conn.transport.name); // prints \"polling\" or \"websocket\"\n     *\n     *   socket.conn.once(\"upgrade\", () => {\n     *     console.log(socket.conn.transport.name); // prints \"websocket\"\n     *   });\n     * });\n     */\n    get conn() {\n        return this.client.conn;\n    }\n    /**\n     * Returns the rooms the socket is currently in.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   console.log(socket.rooms); // Set { <socket.id> }\n     *\n     *   socket.join(\"room1\");\n     *\n     *   console.log(socket.rooms); // Set { <socket.id>, \"room1\" }\n     * });\n     */\n    get rooms() {\n        return this.adapter.socketRooms(this.id) || new Set();\n    }\n    /**\n     * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to\n     * the callback.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.onAny((event, ...args) => {\n     *     console.log(`got event ${event}`);\n     *   });\n     * });\n     *\n     * @param listener\n     */\n    onAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to\n     * the callback. The listener is added to the beginning of the listeners array.\n     *\n     * @param listener\n     */\n    prependAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is received.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   const catchAllListener = (event, ...args) => {\n     *     console.log(`got event ${event}`);\n     *   }\n     *\n     *   socket.onAny(catchAllListener);\n     *\n     *   // remove a specific listener\n     *   socket.offAny(catchAllListener);\n     *\n     *   // or remove all listeners\n     *   socket.offAny();\n     * });\n     *\n     * @param listener\n     */\n    offAny(listener) {\n        if (!this._anyListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAny() {\n        return this._anyListeners || [];\n    }\n    /**\n     * Adds a listener that will be fired when any event is sent. The event name is passed as the first argument to\n     * the callback.\n     *\n     * Note: acknowledgements sent to the client are not included.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.onAnyOutgoing((event, ...args) => {\n     *     console.log(`sent event ${event}`);\n     *   });\n     * });\n     *\n     * @param listener\n     */\n    onAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   socket.prependAnyOutgoing((event, ...args) => {\n     *     console.log(`sent event ${event}`);\n     *   });\n     * });\n     *\n     * @param listener\n     */\n    prependAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is sent.\n     *\n     * @example\n     * io.on(\"connection\", (socket) => {\n     *   const catchAllListener = (event, ...args) => {\n     *     console.log(`sent event ${event}`);\n     *   }\n     *\n     *   socket.onAnyOutgoing(catchAllListener);\n     *\n     *   // remove a specific listener\n     *   socket.offAnyOutgoing(catchAllListener);\n     *\n     *   // or remove all listeners\n     *   socket.offAnyOutgoing();\n     * });\n     *\n     * @param listener - the catch-all listener\n     */\n    offAnyOutgoing(listener) {\n        if (!this._anyOutgoingListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyOutgoingListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyOutgoingListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAnyOutgoing() {\n        return this._anyOutgoingListeners || [];\n    }\n    /**\n     * Notify the listeners for each packet sent (emit or broadcast)\n     *\n     * @param packet\n     *\n     * @private\n     */\n    notifyOutgoingListeners(packet) {\n        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n            const listeners = this._anyOutgoingListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, packet.data);\n            }\n        }\n    }\n    newBroadcastOperator() {\n        const flags = Object.assign({}, this.flags);\n        this.flags = {};\n        return new broadcast_operator_1.BroadcastOperator(this.adapter, new Set(), new Set([this.id]), flags);\n    }\n}\nexports.Socket = Socket;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}