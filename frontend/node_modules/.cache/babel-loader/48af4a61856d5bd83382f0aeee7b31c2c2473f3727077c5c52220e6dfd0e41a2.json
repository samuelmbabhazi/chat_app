{"ast":null,"code":"'use strict';\n\nconst {\n  Duplex\n} = require('stream');\n\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */\nfunction createWebSocketStream(ws, options) {\n  let resumeOnReceiverDrain = true;\n  let terminateOnDestroy = true;\n  function receiverOnDrain() {\n    if (resumeOnReceiverDrain) ws._socket.resume();\n  }\n  if (ws.readyState === ws.CONNECTING) {\n    ws.once('open', function open() {\n      ws._receiver.removeAllListeners('drain');\n      ws._receiver.on('drain', receiverOnDrain);\n    });\n  } else {\n    ws._receiver.removeAllListeners('drain');\n    ws._receiver.on('drain', receiverOnDrain);\n  }\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n  ws.on('message', function message(msg, isBinary) {\n    const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n    if (!duplex.push(data)) {\n      resumeOnReceiverDrain = false;\n      ws._socket.pause();\n    }\n  });\n  ws.once('error', function error(err) {\n    if (duplex.destroyed) return;\n\n    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n    //\n    // - If the `'error'` event is emitted before the `'open'` event, then\n    //   `ws.terminate()` is a noop as no socket is assigned.\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\n    //   event of the `Receiver` object. The listener already closes the\n    //   connection by calling `ws.close()`. This allows a close frame to be\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\n    //   then the close frame might not be sent.\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n    duplex.push(null);\n  });\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n    let called = false;\n    ws.once('error', function error(err) {\n      called = true;\n      callback(err);\n    });\n    ws.once('close', function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n    if (terminateOnDestroy) ws.terminate();\n  };\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n\n    // If the value of the `_socket` property is `null` it means that `ws` is a\n    // client websocket and the handshake failed. In fact, when this happens, a\n    // socket is never assigned to the websocket. Wait for the `'error'` event\n    // that will be emitted by the websocket.\n    if (ws._socket === null) return;\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n        callback();\n      });\n      ws.close();\n    }\n  };\n  duplex._read = function () {\n    if (ws.readyState === ws.OPEN && !resumeOnReceiverDrain) {\n      resumeOnReceiverDrain = true;\n      if (!ws._receiver._writableState.needDrain) ws._socket.resume();\n    }\n  };\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n    ws.send(chunk, callback);\n  };\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\nmodule.exports = createWebSocketStream;","map":{"version":3,"names":["Duplex","require","emitClose","stream","emit","duplexOnEnd","destroyed","_writableState","finished","destroy","duplexOnError","err","removeListener","listenerCount","createWebSocketStream","ws","options","resumeOnReceiverDrain","terminateOnDestroy","receiverOnDrain","_socket","resume","readyState","CONNECTING","once","open","_receiver","removeAllListeners","on","duplex","autoDestroy","objectMode","writableObjectMode","message","msg","isBinary","data","_readableState","toString","push","pause","error","close","_destroy","callback","CLOSED","process","nextTick","called","terminate","_final","endEmitted","finish","_read","OPEN","needDrain","_write","chunk","encoding","send","module","exports"],"sources":["/home/samuel/Documents/chatApp/node_modules/ws/lib/stream.js"],"sourcesContent":["'use strict';\n\nconst { Duplex } = require('stream');\n\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */\nfunction createWebSocketStream(ws, options) {\n  let resumeOnReceiverDrain = true;\n  let terminateOnDestroy = true;\n\n  function receiverOnDrain() {\n    if (resumeOnReceiverDrain) ws._socket.resume();\n  }\n\n  if (ws.readyState === ws.CONNECTING) {\n    ws.once('open', function open() {\n      ws._receiver.removeAllListeners('drain');\n      ws._receiver.on('drain', receiverOnDrain);\n    });\n  } else {\n    ws._receiver.removeAllListeners('drain');\n    ws._receiver.on('drain', receiverOnDrain);\n  }\n\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n\n  ws.on('message', function message(msg, isBinary) {\n    const data =\n      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n\n    if (!duplex.push(data)) {\n      resumeOnReceiverDrain = false;\n      ws._socket.pause();\n    }\n  });\n\n  ws.once('error', function error(err) {\n    if (duplex.destroyed) return;\n\n    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n    //\n    // - If the `'error'` event is emitted before the `'open'` event, then\n    //   `ws.terminate()` is a noop as no socket is assigned.\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\n    //   event of the `Receiver` object. The listener already closes the\n    //   connection by calling `ws.close()`. This allows a close frame to be\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\n    //   then the close frame might not be sent.\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n\n    duplex.push(null);\n  });\n\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n\n    let called = false;\n\n    ws.once('error', function error(err) {\n      called = true;\n      callback(err);\n    });\n\n    ws.once('close', function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n\n    if (terminateOnDestroy) ws.terminate();\n  };\n\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n\n    // If the value of the `_socket` property is `null` it means that `ws` is a\n    // client websocket and the handshake failed. In fact, when this happens, a\n    // socket is never assigned to the websocket. Wait for the `'error'` event\n    // that will be emitted by the websocket.\n    if (ws._socket === null) return;\n\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n        callback();\n      });\n      ws.close();\n    }\n  };\n\n  duplex._read = function () {\n    if (ws.readyState === ws.OPEN && !resumeOnReceiverDrain) {\n      resumeOnReceiverDrain = true;\n      if (!ws._receiver._writableState.needDrain) ws._socket.resume();\n    }\n  };\n\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n\n    ws.send(chunk, callback);\n  };\n\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\n\nmodule.exports = createWebSocketStream;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}